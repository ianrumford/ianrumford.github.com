<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width initial-scale=1">

<meta property="og:title" content="A little sugar with your Clojure Aspect Contracts">
<title>A little sugar with your Clojure Aspect Contracts</title>
<meta property="og:description" content="  TL;DR: clojure-contracts-sugar - some sugar  macros for clojure.core.contractsIntroductionBack in November 2012, in one of my first toe-dippings intoClojur...">
<meta property="og:url" content="http://www.rumford.name/clojure/aspect/contract/sugar/macro/2014/02/19/a-little-sugar-with-your-clojure-aspect-contracts.html">
<meta property="og:site_name" content="An Ostler in IT">
<meta property="og:locale" content="en_UK">
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@ianrumford">
<meta name="twitter:creator" content="@ianrumford">
<meta name="twitter:title" content="A little sugar with your Clojure Aspect Contracts">
<meta name="twitter:description" content="  TL;DR: clojure-contracts-sugar - some sugar  macros for clojure.core.contractsIntroductionBack in November 2012, in one of my first toe-dippings intoClojur...">
<meta name="twitter:url" content="http://www.rumford.name/clojure/aspect/contract/sugar/macro/2014/02/19/a-little-sugar-with-your-clojure-aspect-contracts.html">

<meta name="keywords" content="IT Ostler Horses Courses">

<link rel="icon" href="/images/favicon.ico">
<link rel="stylesheet" href="/css/main.css">
<link rel="canonical" href="http://www.rumford.name/clojure/aspect/contract/sugar/macro/2014/02/19/a-little-sugar-with-your-clojure-aspect-contracts.html">
<link rel="alternate" type="application/atom+xml" title="An Ostler in IT" href="http://www.rumford.name/feed.xml" />

<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script language="Javascript" type="text/javascript">
function search_google()
{
  var query = document.getElementById("google-search").value;
  window.open("http://google.com/search?q=" + query
      + "%20site:" + "http://www.rumford.name");
}
</script>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');

</script>


<script type='text/javascript'>
var blocklink = ['http://humanorightswatch.org','http://o-o-6-o-o.com','http://darodar.com','http://blackhatworth.com','http://hulfingtonpost.com','http://bestwebsitesawards.com','http://darodar.com','http://buttons-for-website.com','http://ilovevitaly.co','http://semalt.com','http://priceg.com','http://simple-share-buttons.com','http://googlsucks.com','http://4webmasters.org','http://aliexpress.com','http://addons.mozilla.org/en-US/firefox/addon/ilovevitaly/','http://free-share-buttons.com','http://buttons-for-your-website.com','http://theguardlan.com','http://buy-cheap-online.info','http://best-seo-offer.com','http://4webmasters.org','http://trafficmonetize.org','http://howtostopreferralspam.eu','http://ilovevitaly.com','http://sanjosestartups.com','http://free-social-buttons.com','http://best-seo-offer.com','http://guardlink.org','http://www.event-tracking.com','http://www3.free-social-buttons.com','http://www1.free-social-buttons.com','http://www2.free-social-buttons.com','http://websites-reviews.com','http://floating-share-buttons.com','http://satellite.maps.ilovevitaly.com','http://free-social-buttons.com','http://www.event-tracking.com','http://erot.co'];
for (var b = blocklink.length; b--;) {
  if (document.referrer.match(blocklink[b]))
    window.location = "http://www.google.com";
}
</script>



<link type="application/atom+xml" rel="alternate" href="http://www.rumford.name/atom.xml" title="An Ostler in IT" />
</head>


<body>

<div class="container">

  <header class="site-header">

  <div class="wrapper">

    <h1 class="site-title"><a href="/">An Ostler in IT</a></h1>
    <h3 class="site-meta">Horses for Courses</h3>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
      <div class="trigger">
        
        
        <a class="page-link" href="/">Home</a>
        
        
        
        <a class="page-link" href="/about/">About</a>
        
        
        
        <a class="page-link" href="/archives/">Archives</a>
        
        
        
        <a class="page-link" href="/categories/">Categories</a>
        
        
        
        <a class="page-link" href="/tags/">Tags</a>
        
        
        
        <a class="page-link" href="/guestbook/"></a>
        
        
        
        <a class="page-link" href="/feed.xml"></a>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      </div>
    </nav>

  </div>

</header>


    

  <div class="page-content col-sm-8">
    <div class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 itemprop="name" class="post-title">A little sugar with your Clojure Aspect Contracts</h1>
    <meta itemprop="keywords" content="" />
    <p class="post-meta">
    Posted in
    
    <a href="/categories/#clojure">clojure</a>, 
    
    <a href="/categories/#aspect">aspect</a>, 
    
    <a href="/categories/#contract">contract</a>, 
    
    <a href="/categories/#sugar">sugar</a>, 
    
    <a href="/categories/#macro">macro</a>
     
    
    <time itemprop="datePublished" datetime="2014-02-19">
    on Feb 19, 2014
    </time>
    </p>
  </header>

  <article class="post-content" itemprop="articleBody">
    <blockquote>
  <p>TL;DR: clojure-contracts-sugar - some sugar  macros for clojure.core.contracts</p>
</blockquote>

<h1 id="introductiona-idorgheadline1a">Introduction<a id="orgheadline1"></a></h1>

<p>Back in November 2012, in one of my first toe-dippings into
<a href="http:///clojure.org">Clojure</a>, I wrote a
<a href="http://ianrumford.github.io/blog/2012/11/17/first-take-on-contracts-in-clojure/">post</a> on my initial experiences
with <a href="http://blog.fogus.me">Michael Fogus’s</a>
<a href="https://github.com/clojure/core.contracts">clojure.core.contracts</a> (hereafter just
<strong>CCC</strong>).</p>

<p>The rest of this post assumes you have a passing familiarity with
<strong>CCC</strong>. If you aren’t, you may find my 
<a href="http://ianrumford.github.io/blog/2012/11/17/first-take-on-contracts-in-clojure/">original post</a> a digestible introduction.</p>

<p>Although using <strong>CCC</strong> for
<em><a href="http://en.wikipedia.org/wiki/Design_by_contract">contracts programming</a></em> is self-evident,
it was the opportunity to use the <a href="http:///clojure.org">Clojure’s</a>
<a href="http://blog.fogus.me/2009/12/21/clojures-pre-and-post/">:pre and :post assertions</a> to support the
concept and potential of <em>aspects</em> as defined originally by
<a href="http://people.cs.ubc.ca/~gregor/">Gregor Kiczales</a> in his work on
<a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">Aspect Oriented Programming</a> (<strong>AOP</strong>).</p>

<p>In this post I’m following through the experiments and ideas of the
<a href="http://ianrumford.github.io/blog/2012/11/17/first-take-on-contracts-in-clojure/">original post</a>, and
illustrating with some examples using a new library
I’ve written recently - <a href="https://github.com/ianrumford/clojure-contracts-sugar">clojure-contracts-sugar</a> (<strong>CHUGAR</strong>).</p>

<p>In the <a href="http://ianrumford.github.io/blog/2012/11/17/first-take-on-contracts-in-clojure/">original post</a> I made the point that <strong>CCC</strong> could do with some
productivity aids - <em>sugar</em> - to ease the rich usage of <strong>CCC</strong>. <strong>CHUGAR</strong>
attempts to supply that <em>sugar</em> and you can think of this post as
partly a <em>getting started</em> tutorial for the library.</p>

<p>In the simplest cases, <strong>CHUGAR</strong> reduces to <strong>CCC</strong> albeit with a slightly
more flexible syntax. If your contracts needs are straightforward, you’re
likely better off using <strong>CCC</strong> or even <a href="http://blog.fogus.me/2009/12/21/clojures-pre-and-post/">:pre and :post assertions</a> 
directly.</p>

<p>That said, I would encourage you though to have a look at the sections
on <em>mnemonics</em> below which offer an easy way to use (and re-use) rich
and flexible aspect contracts.</p>

<p>Note, the usual caveat,  <strong>CHUGAR</strong>  is a work in progress and really is
intended to be only a starting point (foundation) for  explorations of
contracts from <a href="http:///clojure.org">Clojure</a>.  The API is “settling” but may change.</p>

<blockquote>
  <p>A quick note on terminology: in the <a href="http://ianrumford.github.io/blog/2012/11/17/first-take-on-contracts-in-clojure/">original
post</a> I used <strong>suck</strong> to identify
the (input) arguments of a function and <strong>spit</strong> the result (return value). That
“convention” is used extensively both here and in the library’s code.</p>
</blockquote>

<!-- more -->

<h1 id="aspect-oriented-programminga-idorgheadline2a">Aspect Oriented Programming<a id="orgheadline2"></a></h1>

<p>I first bumped into <strong>AOP</strong> reading the <strong>Communications of the ACM’s</strong>
<a href="http://dl.acm.org/citation.cfm?id=383845">October 2001 edition</a> special edition on AOP (paywall
for content). In their <a href="http://dl.acm.org/citation.cfm?id=383845.383853&amp;coll=portal&amp;dl=ACM">introductory article</a> in
that volume, <em>Elrad, Filman and Bader</em> explains the need for AOP like
so:</p>

<blockquote>
  <p>Any structural realization of a system will find that some concerns
are neatly localized within a specific structural piece, while others
cross multiple elements. AOP is focused on mechanisms for simplifying
the realization of such crosscutting concerns.</p>
</blockquote>

<p>and</p>

<blockquote>
  <p>Separating the expressions of multiple concerns in programming
systems promises simpler system evolution, more comprehensible
systems, adaptability, customizability, and easier reuse.</p>
</blockquote>

<p>They go on to highlight the opportunity for a services paradigm for
common requirements such as authentication, logging, etc facilitating
clear separation of concerns: Leaving the application developers to
focus of their agenda whilst minimising the potential for “misuse”,
whether by omission or commission, of the specialist subsystems e.g. authentication
which may be  supported by  other, third,  parties:</p>

<blockquote>
  <p>Implicit invocation is a virtue in this age of increased software
complexity, as domain experts for an application are unlikely to be
familiar with intricacies of specialized algorithms for distribution,
authentication, access control, synchronization, encryption,
redundancy, and so forth, and cannot be trusted to always invoke them
appropriately in their programs.</p>
</blockquote>

<p>In <a href="https://twitter.com/ramnivas">Ramnivas Laddad’s</a> <a href="http://www.manning.com/laddad/">book on AspectJ</a>, he says:</p>

<blockquote>
  <p>AOP is a new methodology that provides separation of crosscutting concerns
by introducing a new unit of modularization—an aspect—that crosscuts other
modules. With AOP you implement crosscutting concerns in aspects instead of
fusing them in the core modules.</p>
</blockquote>

<blockquote>
  <p>The result is that AOP modularizes the cross-cutting concerns in a
clear-cut fashion, yielding a system architecture that is easier to
design, implement, and maintain.</p>
</blockquote>

<p>In another take, in <a href="http://cemerick.com/">Emerick</a>, <a href="http://briancarper.net/">Carper</a> and <a href="http://clj-me.cgrand.net/">Grand’s</a>  book <a href="http://www.clojurebook.com/">Clojure Programming</a>, they say:</p>

<blockquote>
  <p>Aspect-oriented programming (AOP) is a methodology that allows separation of cross-cutting
concerns. In object-oriented code, a behavior or process is often repeated in
multiple classes, or spread across multiple methods. AOP is a way to abstract this
behavior and apply it to classes and methods without using inheritance.</p>
</blockquote>

<h1 id="the-codea-idorgheadline8a">The Code<a id="orgheadline8"></a></h1>

<h2 id="jar-is-on-clojarsa-idorgheadline3a">Jar is on Clojars<a id="orgheadline3"></a></h2>

<p>The jar is on <a href="https://clojars.org/name.rumford/clojure-contracts-sugar">Clojars</a>:</p>

<p><a href="http://leiningen.org/">Leiningen</a> dependency information:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="p">[</span><span class="n">name.rumford/clojure-contracts-sugar</span><span class="w"> </span><span class="s">"0.2.0"</span><span class="p">]</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p><a href="http://maven.apache.org/">Maven</a> dependency information:</p>

<figure class="highlight"><pre><code class="language-xml" data-lang="xml"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="nt">&lt;dependency&gt;</span>
  <span class="nt">&lt;groupId&gt;</span>name.rumford<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId&gt;</span>clojure-contracts-sugar<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;version&gt;</span>0.2.0<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="repo-is-on-githuba-idorgheadline4a">Repo is on Github<a id="orgheadline4"></a></h2>

<p>The <a href="https://github.com/ianrumford/clojure-contracts-sugar">repo</a> is  on <a href="https://github.com/ianrumford/clojure-contracts-sugar">github</a>.
As you might expect, its organised as a <a href="http://leiningen.org/">Leiningen</a>
project so you’ll want Leiningen <a href="https://github.com/technomancy/leiningen">installed</a>.</p>

<p>The project structure is Maven-style but there is only Clojure today:
<em>./src/main/clojure</em> and <em>./src/test/clojure</em>.</p>

<p>The code uses another of my other new libraries
<a href="https://github.com/ianrumford/clojure-carp">clojure-carp</a> for some utility functions,  exceptions, diagnostics and
other miscellany.</p>

<h2 id="documentationa-idorgheadline5a">Documentation<a id="orgheadline5"></a></h2>

<p>The repo’s <em>./doc</em> folder contains the source of this post: its an
<a href="http://www.gnu.org/software/emacs/">emacs</a> <a href="http://orgmode.org/">org</a> file
<a href="http://orgmode.org/org.html#Extracting-source-code">tangled</a> to generate the examples below
in a <a href="http://leiningen.org/">Leiningen</a> project.</p>

<p>The folder also contains an (org and html) file <em>code-notes</em> offering a <em>brief</em>
high-level overview of the main code artefacts.</p>

<h2 id="testsa-idorgheadline6a">Tests<a id="orgheadline6"></a></h2>

<p>There are a number of tests providing reasonable code coverage that can be run from the repo:</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>lein <span class="nb">test </span>aspect-tests1<span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="examplesa-idorgheadline7a">Examples<a id="orgheadline7"></a></h2>

<p>The examples below can be found in the repo’s examples folder
(specifically in <em>./examples/aspect_examples</em>) and they can be run using
<em>lein</em> in the usual way:</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre><span class="nb">cd</span> ./examples/aspect-examples
lein deps
lein run -m aspect-examples1<span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>The examples use a couple of harness functions - <em>will-work</em> and
<em>will-fail</em> - to run tests.</p>

<p><em>will-work</em> takes as arguments the constrained
function and a list of arguments.</p>

<p><em>will-fail</em> similarly takes just the constrained function and its arguments and
catches the <strong>AssertionError</strong> expected to be thrown.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19</pre></td><td class="code"><pre><span class="c1">;; Helper for accessor examples expected to work.  Returns the expected result, else fails
</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">will-work</span><span class="w">
  </span><span class="p">[</span><span class="n">fn-constrained</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">fn-args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">actual-result</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">fn-constrained</span><span class="w"> </span><span class="n">fn-args</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"will-work"</span><span class="w"> </span><span class="s">"worked as expected"</span><span class="w"> </span><span class="s">"actual-result"</span><span class="w"> </span><span class="n">actual-result</span><span class="w"> </span><span class="s">"fn-constrained"</span><span class="w"> </span><span class="n">fn-constrained</span><span class="w"> </span><span class="s">"fn-args"</span><span class="w"> </span><span class="n">fn-args</span><span class="p">)</span><span class="w">
    </span><span class="n">actual-result</span><span class="p">))</span><span class="w">

</span><span class="c1">;; Helper for accessor examples expected to fail.  Catches the expected AssertionError, else fails.
;; A nil return from the function is ok
</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">will-fail</span><span class="w">
  </span><span class="p">[</span><span class="n">fn-constrained</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">fn-args</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">try</span><span class="w">
    </span><span class="p">(</span><span class="nf">do</span><span class="w">
      </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">return-value</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">fn-constrained</span><span class="w"> </span><span class="n">fn-args</span><span class="p">)]</span><span class="w">
        </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">return-value</span><span class="w"> </span><span class="p">(</span><span class="nb">assert</span><span class="w"> </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"will-fail"</span><span class="w"> </span><span class="s">"DID NOT FAIL"</span><span class="w"> </span><span class="s">"did not cause AssertionError"</span><span class="w"> </span><span class="s">"fn-constrained"</span><span class="w"> </span><span class="n">fn-constrained</span><span class="w"> </span><span class="s">"fn-args"</span><span class="w"> </span><span class="n">fn-args</span><span class="w"> </span><span class="s">"RETURN-VALUE"</span><span class="w"> </span><span class="p">(</span><span class="nb">class</span><span class="w"> </span><span class="n">return-value</span><span class="p">)</span><span class="w"> </span><span class="n">return-value</span><span class="p">)))))</span><span class="w">
    </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">AssertionError</span><span class="w"> </span><span class="n">e</span><span class="w">
      </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="s">"will-fail"</span><span class="w"> </span><span class="s">"failed as expected"</span><span class="w"> </span><span class="s">"fn-constrained"</span><span class="w"> </span><span class="n">fn-constrained</span><span class="w"> </span><span class="s">"fn-args"</span><span class="w"> </span><span class="n">fn-args</span><span class="p">))))</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h1 id="using-contract-aspects---apply-v-updatea-idorgheadline14a">Using Contract Aspects - Apply v Update<a id="orgheadline14"></a></h1>

<p>The libary has two main aspect contract macros:
<em>apply-contract-aspects</em> and <em>update-contract-aspects</em>.</p>

<p>The majority of examples below use <em>apply-contract-aspects</em> but
<em>update-contract-aspects</em> could be used just as well.</p>

<p>A couple of very simple examples follow to give a <em>flavour</em> of their
usage with  the details  expanded upon in the following sections.</p>

<h2 id="using-apply-contract-aspectsa-idorgheadline11a">Using apply-contract-aspects<a id="orgheadline11"></a></h2>

<p>The first macro, <em>apply-contract-aspects</em>, applies one or more aspects to an
existing function and returns a <strong>new</strong> function.</p>

<h3 id="example---applying-a-built-in-predicatea-idorgheadline9a">Example - applying a built-in predicate<a id="orgheadline9"></a></h3>

<p>The below will create, from the original function
<em>any-fn</em>, a new constrained function <em>map-fn</em> that will <strong>only</strong> suck a
map as its input argument.  (The return value will be unconstrained.)</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></td><td class="code"><pre><span class="c1">;; Example - applying a built-in predicate
</span><span class="w">
</span><span class="c1">;; any-fn is the "base" function
</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">any-fn</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w">

</span><span class="c1">;; map-fn is the new function constrained to suck a map
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">suck-map-fn1</span><span class="w"> </span><span class="p">(</span><span class="nf">apply-contract-aspects</span><span class="w"> </span><span class="n">any-fn</span><span class="w"> </span><span class="nb">map?</span><span class="p">))</span><span class="w">

</span><span class="c1">;; This will work
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">suck-map-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">

</span><span class="c1">;; But this will fail since suck-map-fn1 can only suck a map
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">suck-map-fn1</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">

</span><span class="c1">;; The original function any-fn is unchanged and not constrained in any way
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">any-fn</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">any-fn</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">any-fn</span><span class="w"> </span><span class="no">:a</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">any-fn</span><span class="w"> </span><span class="mi">99</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<blockquote>
  <p>The map? predicate in the above call to <em>apply-contract-aspects</em> is  the <strong>Contract Definition</strong>.</p>
</blockquote>

<p>Under the covers, <em>apply-contract-aspects</em> generates a <strong>CCC</strong> contract
similar to the  below
where the <em>ctx-aspect2721</em> is the random, but unique, name (gensym) of
the contract function.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre><span class="c1">;; Example - example of the generated clojure.core.contract call
</span><span class="p">(</span><span class="nf">clojure.core.contracts/contract</span><span class="w"> </span><span class="n">ctx-aspect2721</span><span class="w"> </span><span class="s">"\"ctx-aspect2721\""</span><span class="w"> </span><span class="p">[</span><span class="n">arg0</span><span class="p">]</span><span class="w"> </span><span class="p">[(</span><span class="nb">map?</span><span class="w"> </span><span class="n">arg0</span><span class="p">)])</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<blockquote>
  <p>Quick note on argument names: the arguments in a generated contract
are given names <em>arg0</em>, <em>arg1</em>, etc. These names can be used to
 refer explicitly to specific arguments. More on this later.</p>
</blockquote>

<p>Similarly, to suck a vector:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="c1">;; Example - suck a vector
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">suck-vector-fn1</span><span class="w"> </span><span class="p">(</span><span class="nf">apply-contract-aspects</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="nb">vector?</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">suck-vector-fn1</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">

</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">suck-vector-fn1</span><span class="w"> </span><span class="mi">99</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="example---applying-your-own-custom-predicatea-idorgheadline10a">Example - applying your own custom predicate<a id="orgheadline10"></a></h3>

<p>You can of course create and  use your own <strong>custom</strong> predicate function, returning true or false as
decided.  You can constrain multiple input arguments and/or the return
value in a custom predicate.</p>

<p>A simple way to create a custom predicate would be to use <a href="http://blog.fogus.me/2009/12/21/clojures-pre-and-post/">:pre and post assertions</a> 
in an “identity” function.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></td><td class="code"><pre><span class="c1">;; Example - applying your own custom predicate
</span><span class="w">
</span><span class="c1">;; The custom predicate ensures the argument is a map, its keys are keywords and values are numbers.
</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">is-map-with-keyword-keys-and-numeric-values?</span><span class="w">
  </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:pre</span><span class="w"> </span><span class="p">[(</span><span class="nb">map?</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="nb">keyword?</span><span class="w"> </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="n">number?</span><span class="w"> </span><span class="p">(</span><span class="nb">vals</span><span class="w"> </span><span class="n">x</span><span class="p">))]}</span><span class="w">
  </span><span class="n">x</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">map-keyword-keys-numeric-values-fn1</span><span class="w"> </span><span class="p">(</span><span class="nf">apply-contract-aspects</span><span class="w"> </span><span class="n">any-fn</span><span class="w"> </span><span class="n">is-map-with-keyword-keys-and-numeric-values?</span><span class="p">))</span><span class="w">

</span><span class="c1">;; This will work
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">map-keyword-keys-numeric-values-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">

</span><span class="c1">;; But these will fail the contracts
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">map-keyword-keys-numeric-values-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:x</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">map-keyword-keys-numeric-values-fn1</span><span class="w"> </span><span class="p">{</span><span class="s">"x"</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">map-keyword-keys-numeric-values-fn1</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">

</span><span class="c1">;; As before the original function any-fn is unchanged and not constrained in any way
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">any-fn</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">any-fn</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">any-fn</span><span class="w"> </span><span class="no">:a</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">any-fn</span><span class="w"> </span><span class="mi">99</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="using-update-contract-aspectsa-idorgheadline13a">Using update-contract-aspects<a id="orgheadline13"></a></h2>

<p>The second macro, <em>update-contract-aspects</em>, “changes” (using
<em>alter-var-root</em>) an existing function.</p>

<h3 id="example---updating-a-function-with-a-built-in-predicatea-idorgheadline12a">Example - updating a function with a built-in predicate<a id="orgheadline12"></a></h3>

<p>Essentially the same example as above except the source function but <em>any-fn</em> is changed to <strong>only</strong> suck a map.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13</pre></td><td class="code"><pre><span class="c1">;; Example - updating a function with a built-in predicate
</span><span class="w">
</span><span class="c1">;; any-fn is "changed" to now only suck a map
</span><span class="w">
</span><span class="p">(</span><span class="nf">update-contract-aspects</span><span class="w"> </span><span class="n">any-fn</span><span class="w"> </span><span class="nb">map?</span><span class="p">)</span><span class="w">

</span><span class="c1">;; This will work
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">any-fn</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">

</span><span class="c1">;; But this will fail as any-fn can now only suck a map
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">any-fn</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h1 id="applying-contracts-to-many-arguments-and-the-resulta-idorgheadline18a">Applying Contracts to Many Arguments and the Result<a id="orgheadline18"></a></h1>

<p>Many functions will have more than one (suck) argument, 
even different arities, each
likely requiring its own specific <em>assertions</em> (constraints), and the (spit) result
maybe different assertion(s) again.</p>

<p>To support a rich definition of the assertions required by each argument and the return value, 
the contract definition can  be specified as a map with two keys: <em>:suck</em>
and <em>:spit</em> where the value of the keys are the assertions to apply to
the input arguments and return values. An example should clarify.</p>

<h2 id="example---suck-a-map-and-keyword-and-spit-a-vectora-idorgheadline15a">Example - suck a map and keyword and spit a vector<a id="orgheadline15"></a></h2>

<p>The below defines a two argument contract: the first argument
must be a map, the second a keyword; with a vector expected as the
result:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="p">[</span><span class="nb">map?</span><span class="w"> </span><span class="nb">keyword?</span><span class="p">]</span><span class="w"> </span><span class="no">:spit</span><span class="w"> </span><span class="nb">vector?</span><span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre></td><td class="code"><pre><span class="c1">;; Example - suck a map and keyword and spit a vector
</span><span class="w">
</span><span class="c1">;; In this example, the assertion constrains the function to suck a map and keyword
;; and spit a vector.  
</span><span class="w">
</span><span class="c1">;; The function looks up the value of the keyword in the map.
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">suck-map-keyword-spit-vector-fn1</span><span class="w"> </span><span class="p">(</span><span class="nf">apply-contract-aspects</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">k</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="p">[</span><span class="nb">map?</span><span class="w"> </span><span class="nb">keyword?</span><span class="p">]</span><span class="w"> </span><span class="no">:spit</span><span class="w"> </span><span class="nb">vector?</span><span class="p">}))</span><span class="w">

</span><span class="c1">;; This will work as key :c contains a vector
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">suck-map-keyword-spit-vector-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]}</span><span class="w"> </span><span class="no">:c</span><span class="p">)</span><span class="w">

</span><span class="c1">;; But these will fail
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">suck-map-keyword-spit-vector-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:c</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">suck-map-keyword-spit-vector-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:d</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Some notes:</p>

<ul>
  <li>assertions are matched positionally to their arguments</li>
</ul>

<p>The <em>map?</em> constrains <strong>only</strong> the first argument (arg0) and the
<em>keyword?</em> constrains <strong>only</strong> the second argument (arg1); the returned value must be a <em>vector?</em>.</p>

<ul>
  <li>if there is only one argument, the enclosing vector is not needed</li>
</ul>

<p>Just as the return value can be specified as just <em>vector?</em> and not
<em>[vector?]</em>, if the function only sucked a map <em>:suck map?</em> would be sufficient e.g. <em>{:suck map? :spit vector?}</em>.</p>

<h2 id="example---suck-a-map---with-keyword-keys-and-numeric-values---and-keyword-and-spit-a-vectora-idorgheadline16a">Example - suck a map - with keyword keys and numeric values - and keyword and spit a vector<a id="orgheadline16"></a></h2>

<p>To include additional assertions on the map in the previous example to
insist on keyword keys and numeric values, the assertion for the map
argument would be changed to a vector of constraints.</p>

<p>Note the use of
<em>arg0</em> to refer to the input map in the <em>every?</em> clauses.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="p">[[</span><span class="nb">map?</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="nb">keyword?</span><span class="w"> </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="n">arg0</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="n">number?</span><span class="w"> </span><span class="p">(</span><span class="nb">vals</span><span class="w"> </span><span class="n">arg0</span><span class="p">))]</span><span class="w"> </span><span class="nb">keyword?</span><span class="p">]</span><span class="w"> </span><span class="no">:spit</span><span class="w"> </span><span class="nb">vector?</span><span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre></td><td class="code"><pre><span class="c1">;; Example - suck a map - with keyword keys and numeric values - and keyword and spit a vector
</span><span class="w">
</span><span class="c1">;; In this example, the contract constrains the function to suck a map and keyword, spit a number.
</span><span class="w">
</span><span class="c1">;; The map must have keywords keys and numeric values.
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">suck-map-keyword-spit-number-fn1</span><span class="w"> </span><span class="p">(</span><span class="nf">apply-contract-aspects</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">k</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="p">[[</span><span class="nb">map?</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="nb">keyword?</span><span class="w"> </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="n">arg0</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="n">number?</span><span class="w"> </span><span class="p">(</span><span class="nb">vals</span><span class="w"> </span><span class="n">arg0</span><span class="p">))]</span><span class="w"> </span><span class="nb">keyword?</span><span class="p">]</span><span class="w"> </span><span class="no">:spit</span><span class="w"> </span><span class="n">number?</span><span class="p">}))</span><span class="w">

</span><span class="c1">;; This will work
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">suck-map-keyword-spit-number-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:a</span><span class="p">)</span><span class="w">

</span><span class="c1">;; But these will fail their contracts
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">suck-map-keyword-spit-number-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:x</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:a</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">suck-map-keyword-spit-number-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:d</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">suck-map-keyword-spit-number-fn1</span><span class="w"> </span><span class="p">{</span><span class="s">"x"</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:c</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="example---specifying-argument-order-explicitlya-idorgheadline17a">Example - specifying argument order explicitly<a id="orgheadline17"></a></h2>

<p>Specifying the arguments’ order implicitly by their position in the suck assertion list is
natural but there may be times when you want to explicitly define the
argument position and its assertions, irrespective of its position in the
assertion list.</p>

<p>You can do this by providing a map where the keys are the argument
positions and the values the assertion list to apply to that argument.</p>

<p>The example below is a variant of the map and keyword example above but the keyword
is the first argument (key 0) and the map the second (key 1). The map
must have  keyword keys and
numeric values as before.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="w"> </span><span class="no">:keyword</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">[</span><span class="no">:map</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="nb">keyword?</span><span class="w"> </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="n">arg0</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="n">number?</span><span class="w"> </span><span class="p">(</span><span class="nb">vals</span><span class="w"> </span><span class="n">arg0</span><span class="p">))]}</span><span class="w"> </span><span class="no">:spit</span><span class="w"> </span><span class="no">:number</span><span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<blockquote>
  <p>Note the use of <em>arg0</em> to refer to the input map in the <em>every?</em>
clauses <strong>even though</strong> the map is the <strong>second</strong> argument (and will
therefore be <em>arg1</em> in the contract).</p>

  <p>That’s because the <em>every?</em> forms will be rewritten <strong>automatically</strong> to
reflect the map’s  position in the argument order i.e. its <em>arg1</em>. The point is that the
map assertion does not change no matter where the map appears in
the argument order.</p>

  <p>This is similar to when mnemonics are composed - see later.</p>
</blockquote>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15</pre></td><td class="code"><pre><span class="c1">;; Example - specifying argument order explicitly
</span><span class="w">
</span><span class="c1">;; In this example, the arguments are specified by their explicit position in the argument order
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">explicit-argument-order-fn1</span><span class="w"> </span><span class="p">(</span><span class="nf">apply-contract-aspects</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="n">m</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">k</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="w"> </span><span class="no">:keyword</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">[</span><span class="no">:map</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="nb">keyword?</span><span class="w"> </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="n">arg0</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="n">number?</span><span class="w"> </span><span class="p">(</span><span class="nb">vals</span><span class="w"> </span><span class="n">arg0</span><span class="p">))]}</span><span class="w"> </span><span class="no">:spit</span><span class="w"> </span><span class="no">:number</span><span class="p">}))</span><span class="w">

</span><span class="c1">;; This will work
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">explicit-argument-order-fn1</span><span class="w"> </span><span class="no">:a</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">

</span><span class="c1">;; But these will fail their contracts
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">explicit-argument-order-fn1</span><span class="w"> </span><span class="no">:a</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:x</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">explicit-argument-order-fn1</span><span class="w"> </span><span class="no">:d</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">explicit-argument-order-fn1</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="p">{</span><span class="s">"x"</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>BTW The contract looks like this. Note the map is <em>arg1</em>.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="p">(</span><span class="nf">clojure.core.contracts/contract</span><span class="w"> </span><span class="n">ctx-aspect3000</span><span class="w"> </span><span class="s">"\"ctx-aspect3000\""</span><span class="w"> </span><span class="p">[</span><span class="n">arg0</span><span class="w"> </span><span class="n">arg1</span><span class="p">]</span><span class="w"> </span><span class="p">[(</span><span class="nb">keyword?</span><span class="w"> </span><span class="n">arg0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">map?</span><span class="w"> </span><span class="n">arg1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="nb">keyword?</span><span class="w"> </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="n">arg1</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="n">number?</span><span class="w"> </span><span class="p">(</span><span class="nb">vals</span><span class="w"> </span><span class="n">arg1</span><span class="p">))</span><span class="w"> </span><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">number?</span><span class="w"> </span><span class="n">%</span><span class="p">)])</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h1 id="using-cccs-contract-definition-forma-idorgheadline23a">Using CCC’s contract definition form<a id="orgheadline23"></a></h1>

<p>For those familiar with <strong>CCC</strong>, you can also use <strong>CCC’s</strong> contract specification format as well.
But note the signature vector (e.g. ‘[v]) and assertion vector (e.g.
‘[map?]) must be inside a third  vector:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="p">[[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="nb">map?</span><span class="p">]]</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="example---using-cccs-format-to-suck-a-map-and-spit-a-vectora-idorgheadline19a">Example - Using CCC’s format to suck a map and spit a vector<a id="orgheadline19"></a></h2>

<p>The assertion vector can have any assertions supported by <strong>CCC</strong>.  For example, here the constrained function
below sucks a map and spits a vector:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="c1">;; Example - suck map and spit vector using CCC form
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">suck-map-spit-vector-fn1</span><span class="w"> </span><span class="p">(</span><span class="nf">apply-contract-aspects</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="no">:c</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="p">[[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="nb">map?</span><span class="w"> </span><span class="n">=&gt;</span><span class="w"> </span><span class="nb">vector?</span><span class="p">]]))</span><span class="w">

</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">suck-map-spit-vector-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]})</span><span class="w">

</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">suck-map-spit-vector-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">1</span><span class="p">})</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="example---using-cccs-format-to-suck-a-map-with-keyword-keys-and-spit-a-vectora-idorgheadline20a">Example - Using CCC’s format to suck a map with keyword keys, and spit a vector<a id="orgheadline20"></a></h2>

<p>Or, additionally, to ensure the map’s keys are all keywords:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="c1">;; Example - suck map, spit vector but also all map keys are keywords
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">suck-map-keyword-keys-fn1</span><span class="w"> </span><span class="p">(</span><span class="nf">apply-contract-aspects</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="no">:c</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="p">[[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="nb">map?</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="nb">keyword?</span><span class="w"> </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="n">v</span><span class="p">))</span><span class="w"> </span><span class="n">=&gt;</span><span class="w"> </span><span class="nb">vector?</span><span class="p">]]))</span><span class="w">

</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">suck-map-keyword-keys-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]})</span><span class="w">

</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">suck-map-keyword-keys-fn1</span><span class="w"> </span><span class="p">{</span><span class="s">"x"</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">1</span><span class="p">})</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="example---using-cccs-format-with-rich-assertionsa-idorgheadline21a">Example - using CCC’s format with rich assertions<a id="orgheadline21"></a></h2>

<p><strong>CCC</strong>  supports the specification of rich
assertions. For a two argument function (map, keyword), where the map’s
keys are keywords, the values numbers; and the return value
unconstrained, in CCC’s format, the full contract would look like this:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="p">[[</span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="p">[(</span><span class="nb">map?</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="nb">keyword</span><span class="w"> </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="n">number?</span><span class="w"> </span><span class="p">(</span><span class="nb">vals</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">keyword?</span><span class="w"> </span><span class="n">k</span><span class="p">)]]</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>An example:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre></td><td class="code"><pre><span class="c1">;; Example - using CCC's format with rich assertions
</span><span class="w">
</span><span class="c1">;; In this example, the assertion constrains the function to suck a map,
;; with keywords keys and numeric values, and a keyword.
</span><span class="w">
</span><span class="c1">;; The returned value is unconstrained
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">map-keyword-keys-numeric-vals-fn2</span><span class="w"> </span><span class="p">(</span><span class="nf">apply-contract-aspects</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">k</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="p">[[</span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="p">[(</span><span class="nb">map?</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="nb">keyword</span><span class="w"> </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="n">number?</span><span class="w"> </span><span class="p">(</span><span class="nb">vals</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">keyword?</span><span class="w"> </span><span class="n">k</span><span class="p">)]]))</span><span class="w">

</span><span class="c1">;; This will work and return nil as the return value is not constrained
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">map-keyword-keys-numeric-vals-fn2</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:d</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">map-keyword-keys-numeric-vals-fn2</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="s">"d"</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">map-keyword-keys-numeric-vals-fn2</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:x</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:a</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">map-keyword-keys-numeric-vals-fn2</span><span class="w"> </span><span class="p">{</span><span class="s">"x"</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:d</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="example---using-cccs-format-in-a-suck-definitiona-idorgheadline22a">Example - using CCC’s format in a suck definition<a id="orgheadline22"></a></h2>

<p>You can also use a <strong>CCC</strong> form in a suck definition. Likely confusing,
 notably because you have to be quite careful as to what assertions are
 applied to which arguments, but it works. The <strong>CCC</strong> form works as if
 it is a mnemonic (see later) in the same position.</p>

<p>Note in the example below the <em>map?</em> assertion for the result in the
<strong>CCC</strong> form has been discarded because it is not a <em>suck</em> assertion;
the <em>spit</em> <em>:number</em> assertion is applied to the result.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10</pre></td><td class="code"><pre><span class="c1">;; Example - using CCC's format in a suck definition
</span><span class="w">
</span><span class="c1">;; Not the clearest way of specifying the contract
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">using-ccc-form-in-the-suck-definition-fn1</span><span class="w"> </span><span class="p">(</span><span class="nf">apply-contract-aspects</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">s</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">k</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="p">[</span><span class="no">:map</span><span class="w"> </span><span class="p">[[</span><span class="n">k</span><span class="w"> </span><span class="n">s</span><span class="p">]</span><span class="w"> </span><span class="p">[(</span><span class="nb">keyword?</span><span class="w"> </span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">string?</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="n">=&gt;</span><span class="w"> </span><span class="nb">map?</span><span class="p">]]]</span><span class="w"> </span><span class="no">:spit</span><span class="w"> </span><span class="no">:number</span><span class="p">}</span><span class="w"> </span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">using-ccc-form-in-the-suck-definition-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:a</span><span class="w"> </span><span class="s">"s2"</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">using-ccc-form-in-the-suck-definition-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="s">"d"</span><span class="w"> </span><span class="s">"s2"</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">using-ccc-form-in-the-suck-definition-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:x</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">using-ccc-form-in-the-suck-definition-fn1</span><span class="w"> </span><span class="p">{</span><span class="s">"x"</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:d</span><span class="w"> </span><span class="s">"s2"</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h1 id="using-mnemonicsa-idorgheadline40a">Using Mnemonics<a id="orgheadline40"></a></h1>

<p>At their simplest, <strong>mnemonic</strong> are (Clojure) keyword “short-hands” for a contract assertion(s).</p>

<h2 id="using-mnemonics-for-built-in-predicatesa-idorgheadline26a">Using Mnemonics for Built-in Predicates<a id="orgheadline26"></a></h2>

<p>So far the assertions used have used Clojure’s built-in predicates such as <em>map?</em>,
<em>keyword?</em> and <em>vector?</em> but we could have used their keyword mnemonics
<em>:map</em>, <em>:keyword</em> or <em>:vector</em>.  In fact any predicate of the form
<em>name?</em> can be replaced by its keyword form <em>:name</em> (as long as the
symbol can be <strong>resolved</strong>).</p>

<h3 id="example---using-a-built-in-mnemonica-idorgheadline24a">Example - using a built-in mnemonic<a id="orgheadline24"></a></h3>

<p>To repeat the example above using <em>map?</em> but with <em>:map</em>:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14</pre></td><td class="code"><pre><span class="c1">;; Example - using a built-in mnemonic
</span><span class="w">
</span><span class="c1">;; This is a contrived example to show the symmetry when using a buit-in mnemonic.
;; BTW The function hard-codes a map as it return value so will always satisfy the spit constraint.
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">mnemonic-suck-and-spit-map-fn1</span><span class="w"> </span><span class="p">(</span><span class="nf">apply-contract-aspects</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="no">:x</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:y</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:z</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w"> </span><span class="no">:map</span><span class="p">))</span><span class="w">

</span><span class="c1">;; This will work because the argument is a map and the (hard-coded) return value is a map
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">mnemonic-suck-and-spit-map-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">

</span><span class="c1">;; But this fail sicne the argument is not a map
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">mnemonic-suck-and-spit-map-fn1</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<blockquote>
  <p>Note: using a built-in mnemonic as the full contract definition will apply the assertion(s) to <strong>both</strong> the input argument and also return value.</p>
</blockquote>

<h3 id="example---applying-built-in-mnemonics-to-individual-arguments-and-the-resulta-idorgheadline25a">Example - applying built-in mnemonics to individual arguments and the result<a id="orgheadline25"></a></h3>

<p>Repeating one of the examples above sucking a map and keyword and
returning a vector, all that has changed is the
assertions now  use keywords.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15</pre></td><td class="code"><pre><span class="c1">;; Example - applying built-in mnemonics to individual arguments and the result
</span><span class="w">
</span><span class="c1">;; In this example, built-in mnemonics are used to constrains the
;; function to suck a map and keyword and spit a vector.
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">suck-map-keyword-spit-vector-fn1</span><span class="w"> </span><span class="p">(</span><span class="nf">apply-contract-aspects</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">k</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="p">[</span><span class="no">:map</span><span class="w"> </span><span class="no">:keyword</span><span class="p">]</span><span class="w"> </span><span class="no">:spit</span><span class="w"> </span><span class="no">:vector</span><span class="p">}))</span><span class="w">

</span><span class="c1">;; This will work as key :c contains a vector
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">suck-map-keyword-spit-vector-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]}</span><span class="w"> </span><span class="no">:c</span><span class="p">)</span><span class="w">

</span><span class="c1">;; But these will fail their contract
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">suck-map-keyword-spit-vector-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:c</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">suck-map-keyword-spit-vector-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:d</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<blockquote>
  <p>Note: built-in mnemonics in the map form of a contract
definition apply the assertion <strong>only</strong> to the mnemonic’s corresponding
argument.</p>
</blockquote>

<h2 id="changing-a-built-in-mnemonic-contract-definitiona-idorgheadline28a">Changing a Built-in Mnemonic Contract Definition<a id="orgheadline28"></a></h2>

<p>Replacing a built-in predicate with its keyword mnemonic is not a big win,
just saving a few characters in the assertion definition.</p>

<p>The real power of
mnemonics comes from the opportunity to change the definition of an
existing mnemonic (or add custom ones - see later).</p>

<p>The  <em>configure-contracts-store</em> macro manages mnemonics definitions.</p>

<h3 id="example---redefining-the-map-built-in-mnemonica-idorgheadline27a">Example - redefining the :map built-in mnemonic<a id="orgheadline27"></a></h3>

<p>Say you wanted to re-define the built-in <em>:map</em> mnemonic to check  <strong>always</strong> that a map’s keys are keywords:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="c1">;; Changing a Built-in Mnemonic Contract Definition
</span><span class="w">
</span><span class="c1">;; Change the built-in :map mnemonics to also check the keys are keywords
</span><span class="w">
</span><span class="p">(</span><span class="nf">configure-contracts-store</span><span class="w"> </span><span class="n">aspect-mnemonic-definitions</span><span class="w"> </span><span class="p">{</span><span class="no">:map</span><span class="w"> </span><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="p">[[</span><span class="nb">map?</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="nb">keyword?</span><span class="w"> </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="n">arg0</span><span class="p">))]]}})</span><span class="w"> </span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Using the updated mnemonic is exactly the same as before:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13</pre></td><td class="code"><pre><span class="c1">;; Example - re-defining the :map built-in mnemonic
</span><span class="w">
</span><span class="c1">;; In this example, the :map built-in mnemonic has been changed to check the keys are keywords.
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">suck-map-keyword-spit-vector-fn1</span><span class="w"> </span><span class="p">(</span><span class="nf">apply-contract-aspects</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">k</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="p">[</span><span class="no">:map</span><span class="w"> </span><span class="no">:keyword</span><span class="p">]</span><span class="w"> </span><span class="no">:spit</span><span class="w"> </span><span class="no">:vector</span><span class="p">}))</span><span class="w">

</span><span class="c1">;; This will work as key :c contains a vector
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">suck-map-keyword-spit-vector-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]}</span><span class="w"> </span><span class="no">:c</span><span class="p">)</span><span class="w">

</span><span class="c1">;; But this will fail the contract as "x" is not a keyword.
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">suck-map-keyword-spit-vector-fn1</span><span class="w"> </span><span class="p">{</span><span class="s">"x"</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:c</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="adding-and-using-custom-mnemonicsa-idorgheadline30a">Adding and Using Custom Mnemonics<a id="orgheadline30"></a></h2>

<p>Just as you can update the definition of a built-in mnemonic, you can
add / update your own <strong>custom</strong> mnemonics.</p>

<h3 id="example---using-a-custom-mnemonica-idorgheadline29a">Example - using a custom mnemonic<a id="orgheadline29"></a></h3>

<p>Say you wanted to define a custom mnemonic that “packages” the assertions
that a map’s keys are keywords and all the values are numeric:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8</pre></td><td class="code"><pre><span class="c1">;; Example - add a new mnemonic to the contracts store
</span><span class="w">
</span><span class="c1">;; The new mnemonic - :map-keyword-keys-numeric-vals - constrains an
;; argument to be a map with keyword keys and numeric values.
</span><span class="w">
</span><span class="p">(</span><span class="nf">configure-contracts-store</span><span class="w">
 </span><span class="n">aspect-mnemonic-definitions</span><span class="w">
 </span><span class="p">{</span><span class="no">:map-keyword-keys-numeric-vals</span><span class="w"> </span><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="p">[[</span><span class="nb">map?</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="nb">keyword?</span><span class="w"> </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="n">arg0</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="n">number?</span><span class="w"> </span><span class="p">(</span><span class="nb">vals</span><span class="w"> </span><span class="n">arg0</span><span class="p">))]]}})</span><span class="w"> </span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>To use the new mnemonic is straightforward.  Note the mnemonic appears
as the first value in the <em>:suck</em> assertion vector, the other entry
being <em>:keyword</em>.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17</pre></td><td class="code"><pre><span class="c1">;; Example - using a custom mnemonic
</span><span class="w">
</span><span class="c1">;; In this example, the assertion constrains the function to suck a map and keyword, spit a number.
</span><span class="w">
</span><span class="c1">;; The map must have keywords keys and numeric values.
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">mnemonic-suck-map-keyword-spit-number-fn1</span><span class="w"> </span><span class="p">(</span><span class="nf">apply-contract-aspects</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">k</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="p">[</span><span class="no">:map-keyword-keys-numeric-vals</span><span class="w"> </span><span class="no">:keyword</span><span class="p">]</span><span class="w"> </span><span class="no">:spit</span><span class="w"> </span><span class="no">:number</span><span class="p">}))</span><span class="w">

</span><span class="c1">;; This will work
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">mnemonic-suck-map-keyword-spit-number-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:a</span><span class="p">)</span><span class="w">

</span><span class="c1">;; But these will fail their contracts
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">mnemonic-suck-map-keyword-spit-number-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:x</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:a</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">mnemonic-suck-map-keyword-spit-number-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:d</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">mnemonic-suck-map-keyword-spit-number-fn1</span><span class="w"> </span><span class="p">{</span><span class="s">"x"</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:c</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="using-a-custom-mnemonic-to-package-multiple-argumentsa-idorgheadline32a">Using a Custom Mnemonic to package multiple arguments<a id="orgheadline32"></a></h2>

<p>You can go a step farther from the previous example and add the assertion for the second
argument to be a keyword into the mnemonic as well:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7</pre></td><td class="code"><pre><span class="c1">;; Using a Custom Mnemonic to package multiple arguments
</span><span class="w">
</span><span class="c1">;; The new mnemonic combines the assertions to ensure the first argument
;; is a map with keyword keys and numerics value and also the requirement
;; for the second argument to be a keyword.
</span><span class="w">
</span><span class="p">(</span><span class="nf">configure-contracts-store</span><span class="w"> </span><span class="n">aspect-mnemonic-definitions</span><span class="w"> </span><span class="p">{</span><span class="no">:suck-map-keyword-keys-numeric-vals-and-keyword</span><span class="w"> </span><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="p">[[</span><span class="nb">map?</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="nb">keyword?</span><span class="w"> </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="n">arg0</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="n">number?</span><span class="w"> </span><span class="p">(</span><span class="nb">vals</span><span class="w"> </span><span class="n">arg0</span><span class="p">))]</span><span class="w"> </span><span class="nb">keyword?</span><span class="p">]}})</span><span class="w"> </span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="example---using-a-custom-multiple-argument-suck-mnemonica-idorgheadline31a">Example - using a custom multiple argument suck mnemonic<a id="orgheadline31"></a></h3>

<p>In this example a multiple argument mnemonic replaces the whole <em>:suck</em> definition.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12</pre></td><td class="code"><pre><span class="c1">;; Example - using a custom multiple argument suck mnemonic
</span><span class="w">
</span><span class="c1">;; In this example, the map assertion uses a mnemonic to ensure keywords keys and numeric values.
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">mnemonic-suck-map-keyword-spit-number-fn2</span><span class="w"> </span><span class="p">(</span><span class="nf">apply-contract-aspects</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">k</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="no">:suck-map-keyword-keys-numeric-vals-and-keyword</span><span class="w"> </span><span class="no">:spit</span><span class="w"> </span><span class="no">:number</span><span class="p">}))</span><span class="w">

</span><span class="c1">;; Using the same tests as above
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">mnemonic-suck-map-keyword-spit-number-fn2</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:a</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">mnemonic-suck-map-keyword-spit-number-fn2</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:x</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:a</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">mnemonic-suck-map-keyword-spit-number-fn2</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:d</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">mnemonic-suck-map-keyword-spit-number-fn2</span><span class="w"> </span><span class="p">{</span><span class="s">"x"</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:c</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="using-a-custom-mnemonic-to-package-the-complete-contracta-idorgheadline34a">Using a Custom Mnemonic to package the complete contract<a id="orgheadline34"></a></h2>

<p>Its just a small step from the multi argument example to packaging
the whole contract in a custom mnemonic:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11</pre></td><td class="code"><pre><span class="c1">;; Using a Custom Mnemonic to package the complete contract
</span><span class="w">
</span><span class="c1">;; The custom mnemonic combines the assertions to ensure the first
;; argument is a map with keyword keys and numerics value and also the
;; requirement for the second argument to be a keywork. It also includes
;; the requirement for the return value to be a number.
</span><span class="w">
</span><span class="p">(</span><span class="nf">configure-contracts-store</span><span class="w">
 </span><span class="n">aspect-mnemonic-definitions</span><span class="w">
 </span><span class="p">{</span><span class="no">:contract-suck-map-keyword-keys-numeric-vals-and-keyword-spit-number</span><span class="w"> 
  </span><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="p">[[</span><span class="nb">map?</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="nb">keyword?</span><span class="w"> </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="n">arg0</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="n">number?</span><span class="w"> </span><span class="p">(</span><span class="nb">vals</span><span class="w"> </span><span class="n">arg0</span><span class="p">))]</span><span class="w"> </span><span class="nb">keyword?</span><span class="p">]</span><span class="w"> </span><span class="no">:spit</span><span class="w"> </span><span class="no">:number</span><span class="p">}})</span><span class="w"> </span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="example---using-a-custom-mnemonic-to-package-the-whole-contracta-idorgheadline33a">Example - using a custom mnemonic to package the whole contract<a id="orgheadline33"></a></h3>

<p>In this example the complete contract mnemonic replaces the whole
contract map form.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13</pre></td><td class="code"><pre><span class="c1">;; Example - using a custom mnemonic to package the whole contract
</span><span class="w">
</span><span class="c1">;; In this example, the a mnemonic packages the complete assertion
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">mnemonic-suck-map-keyword-spit-number-fn3</span><span class="w"> 
  </span><span class="p">(</span><span class="nf">apply-contract-aspects</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">k</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="no">:contract-suck-map-keyword-keys-numeric-vals-and-keyword-spit-number</span><span class="p">))</span><span class="w">

</span><span class="c1">;; Exactly the same tests as above
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">mnemonic-suck-map-keyword-spit-number-fn3</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:a</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">mnemonic-suck-map-keyword-spit-number-fn3</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:x</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:a</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">mnemonic-suck-map-keyword-spit-number-fn3</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:d</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">mnemonic-suck-map-keyword-spit-number-fn3</span><span class="w"> </span><span class="p">{</span><span class="s">"x"</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:c</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="using-mnemonics-in-custom-mnemonicsa-idorgheadline36a">Using Mnemonics in Custom Mnemonics<a id="orgheadline36"></a></h2>

<p>You can use mnemonics in the <strong>composition</strong>  of other, richer mnemonics (although
beware the infinite recursion gotcha mentioned below).</p>

<p>For example, create a custom mnemonic - <em>:suck-map-special</em> - to constrain a map to have
keyword keys and numeric values, and use that mnemonic in another
mnemonic - <em>:suck-map-special-and-keyword</em> - to include the keyword as the second argument. And finally use the
second mnemonic to specify the full contract for a two argument function sucking
the constrained map and a
keyword, and also spitting a number - <em>:contract-suck-map-special-and-keyword-spit-number</em>.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15</pre></td><td class="code"><pre><span class="c1">;; Using Mnemonics in Custom Mnemeonics
</span><span class="w">
</span><span class="c1">;; The first customer mnemonic constrains a map to have keyword keys and numeric values.
</span><span class="w">
</span><span class="c1">;; The second custome mnemonic speficiy the constrained map and a keyword as the second argument.
</span><span class="w">
</span><span class="c1">;; The third custom mnemonic uses the second mnemonic to build a
;; complete contract mnemonic for a two argument function sucking the
;; constrained map and a keyword, and spitting a number.
</span><span class="w">
</span><span class="p">(</span><span class="nf">configure-contracts-store</span><span class="w">
 </span><span class="n">aspect-mnemonic-definitions</span><span class="w">
 </span><span class="p">{</span><span class="no">:suck-map-special</span><span class="w"> </span><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="p">[[</span><span class="nb">map?</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="nb">keyword?</span><span class="w"> </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="n">arg0</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="n">number?</span><span class="w"> </span><span class="p">(</span><span class="nb">vals</span><span class="w"> </span><span class="n">arg0</span><span class="p">))]]}</span><span class="w">
  </span><span class="no">:suck-map-special-and-keyword</span><span class="w"> </span><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="p">[</span><span class="no">:suck-map-special</span><span class="w"> </span><span class="no">:keyword</span><span class="p">]}</span><span class="w">
  </span><span class="no">:contract-suck-map-special-and-keyword-spit-number</span><span class="w"> </span><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="no">:suck-map-special-and-keyword</span><span class="w"> </span><span class="no">:spit</span><span class="w"> </span><span class="no">:number</span><span class="p">}})</span><span class="w"> </span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="example---using-a-mnemonic-containing-mnemonicsa-idorgheadline35a">Example - using a mnemonic containing mnemonics<a id="orgheadline35"></a></h3>

<p>The example is exactly the same as the one above, but the use of “sub”
mnemonics is transparent.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12</pre></td><td class="code"><pre><span class="c1">;; Example - using a mnemonic containing mnemonics
</span><span class="w">
</span><span class="c1">;; In this example, the three level mnemonic packages the complete assertion
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">mnemonic-suck-map-special-keyword-spit-number-fn1</span><span class="w"> </span><span class="p">(</span><span class="nf">apply-contract-aspects</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">k</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="no">:contract-suck-map-special-and-keyword-spit-number</span><span class="p">))</span><span class="w">

</span><span class="c1">;; Exactly the same tests as above
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">mnemonic-suck-map-special-keyword-spit-number-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:a</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">mnemonic-suck-map-special-keyword-spit-number-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:x</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:a</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">mnemonic-suck-map-special-keyword-spit-number-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:d</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">mnemonic-suck-map-special-keyword-spit-number-fn1</span><span class="w"> </span><span class="p">{</span><span class="s">"x"</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="no">:c</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="composing-mnemonics---resolving-argumentsa-idorgheadline39a">Composing Mnemonics - resolving arguments<a id="orgheadline39"></a></h2>

<p>In the examples above, mnemonics were always the first entry
in the value of a suck or spit key - see the three level composed
mnemonic immediately above.</p>

<p>Most the time the assertion (e.g. <em>:map</em>) did <strong>not</strong> need to include (specify) the
name (symbol)
of the argument the assertion would be applied to; the name was
deduced from the assertion’s position in the value of the suck / spit key.</p>

<p>The only time an explicit argument name  appeared was  <em>arg0</em>
in the <em>every?</em> assertion clauses because the map was the first
argument.</p>

<p>But what if the map was not the first argument?</p>

<p>Lets recast the <em>:suck-map-special-and-keyword</em>
mnemonic to expect the <em>:keyword</em> first and  the <em>:map-special</em> second <strong>but continue to use</strong>
the <em>:suck-map-special</em> mnemonic even though the latter expects (and
defines) the map
to be <em>arg0</em>:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="p">(</span><span class="nf">configure-contracts-store</span><span class="w">
 </span><span class="n">aspect-mnemonic-definitions</span><span class="w">
 </span><span class="p">{</span><span class="no">:suck-keyword-and-map-special</span><span class="w"> </span><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="p">[</span><span class="no">:keyword</span><span class="w"> </span><span class="no">:suck-map-special</span><span class="p">]}</span><span class="w">
  </span><span class="no">:contract-suck-keyword-and-map-special-spit-number</span><span class="w"> </span><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="no">:suck-keyword-and-map-special</span><span class="w"> </span><span class="no">:spit</span><span class="w"> </span><span class="no">:number</span><span class="p">}})</span><span class="w"> </span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="example---swapping-the-keyword-and-map-in-the-three-level-composed-mnemonicsa-idorgheadline37a">Example - swapping the keyword and map in the three level composed mnemonics<a id="orgheadline37"></a></h3>

<p>An example using the swapped argument third level mnemonic <em>:contract-suck-keyword-and-map-special-spit-number</em></p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12</pre></td><td class="code"><pre><span class="c1">;; Example - swapping the keyword and map in the three level composed mnemonics
</span><span class="w">
</span><span class="c1">;; In this example, the keyword and map are swapped in the three level mnemonic
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">mnemonic-suck-keyword-map-special-spit-number-fn1</span><span class="w"> </span><span class="p">(</span><span class="nf">apply-contract-aspects</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">k</span><span class="w"> </span><span class="n">m</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">k</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="no">:contract-suck-keyword-and-map-special-spit-number</span><span class="w"> </span><span class="p">))</span><span class="w">

</span><span class="c1">;; The same tests as above but the arguments swapped
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">mnemonic-suck-keyword-map-special-spit-number-fn1</span><span class="w"> </span><span class="no">:a</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">mnemonic-suck-keyword-map-special-spit-number-fn1</span><span class="w"> </span><span class="no">:a</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:x</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">mnemonic-suck-keyword-map-special-spit-number-fn1</span><span class="w"> </span><span class="no">:d</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">mnemonic-suck-keyword-map-special-spit-number-fn1</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="p">{</span><span class="s">"x"</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">})</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>The behaviour is  as expected but the generated contract look similar to
this:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre><span class="c1">;; Example - swapping the keyword and map in the three level composed mnemonics
</span><span class="p">(</span><span class="nf">clojure.core.contracts/contract</span><span class="w"> </span><span class="n">ctx-aspect2879</span><span class="w"> </span><span class="s">"\"ctx-aspect2879\""</span><span class="w"> </span><span class="p">[</span><span class="n">arg0</span><span class="w"> </span><span class="n">arg1</span><span class="p">]</span><span class="w"> </span><span class="p">[(</span><span class="nb">keyword?</span><span class="w"> </span><span class="n">arg0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">map?</span><span class="w"> </span><span class="n">arg1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="nb">keyword?</span><span class="w"> </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="n">arg1</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="n">number?</span><span class="w"> </span><span class="p">(</span><span class="nb">vals</span><span class="w"> </span><span class="n">arg1</span><span class="p">))</span><span class="w"> </span><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">number?</span><span class="w"> </span><span class="n">%</span><span class="p">)])</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Some notes:</p>

<ul>
  <li>
    <p>The <em>arg0</em> in the canonical definition of the <em>:map-special</em> mnemonic has been automatically rewritten in the final contract to be <em>arg1</em> i.e. the second argument. <em>argo</em> refers to the <em>:keyword</em> (first) argument.</p>
  </li>
  <li>
    <p>More generally, explicitly specified arguments in a mnemonic are automatically <strong>shifted right</strong> to whatever position the mnemonic has in the assertion clause. This applies recursively for composed mnemonics.</p>
  </li>
  <li>
    <p>So when creating mnemonics, if you need to use explicit argument names (arg0, arg1, arg2, etc), name them relative to the mnemonic’s argument order and they can be composed successfully.</p>
  </li>
</ul>

<h3 id="example---using-absolute-arguments-in-mnemonicsa-idorgheadline38a">Example - using absolute arguments in mnemonics<a id="orgheadline38"></a></h3>

<p>Much (most?) of the time relative arguments names suffice.  But
there may be times when using composed mnemonics when you need to
specify (refer to) absolute argument names.</p>

<p>A rather contrived scenario: say you needed to define
mnemonics with relative arguments but use an absolute argument inside the
relative mnemonic. Concretely:  e.g. if the first argument is a map but
the third (relative) argument must be a keyword that is a key in the
map.</p>

<p>Note the <em>:keyword-in-first-argument-map</em> below uses <em>arg0</em> to refer
to itself (i.e. the keyword) but <em>abs-arg0</em> to refer to  the first argument (i.e. the map).</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre><span class="p">(</span><span class="nf">configure-contracts-store</span><span class="w">
 </span><span class="n">aspect-mnemonic-definitions</span><span class="w">
 </span><span class="p">{</span><span class="no">:keyword-in-first-argument-map</span><span class="w"> </span><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="p">[[</span><span class="no">:keyword</span><span class="w"> </span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="n">abs-arg0</span><span class="w"> </span><span class="n">arg0</span><span class="p">)]]}})</span><span class="w"> </span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>The example follows the familiar format:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16</pre></td><td class="code"><pre><span class="c1">;; Example - using absolute arguments in mnemonics
</span><span class="w">
</span><span class="c1">;; This function takes a map, string and keyword, and returns a number.
</span><span class="w">
</span><span class="c1">;; The map must have keyword keys and numberic values.
</span><span class="w">
</span><span class="c1">;; The keyword must exist in the map
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">absolute-argument-mnemonic-fn1</span><span class="w"> </span><span class="p">(</span><span class="nf">apply-contract-aspects</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">k</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="p">[</span><span class="no">:suck-map-special</span><span class="w"> </span><span class="no">:string</span><span class="w"> </span><span class="no">:keyword-in-first-argument-map</span><span class="p">]</span><span class="w"> </span><span class="no">:spit</span><span class="w"> </span><span class="no">:number</span><span class="p">}))</span><span class="w">

</span><span class="c1">;; The same tests as above but the arguments swapped
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">absolute-argument-mnemonic-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="s">"s1"</span><span class="w"> </span><span class="no">:a</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">absolute-argument-mnemonic-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="no">:x</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="s">"s1"</span><span class="w"> </span><span class="no">:a</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">absolute-argument-mnemonic-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="s">"s1"</span><span class="w"> </span><span class="no">:d</span><span class="p">)</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">absolute-argument-mnemonic-fn1</span><span class="w"> </span><span class="p">{</span><span class="s">"x"</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">}</span><span class="w"> </span><span class="s">"s1"</span><span class="w"> </span><span class="no">:c</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>For reference, the contract looks like the below, the <em>abs-arg0</em> has
been rewritten to <em>arg0</em> while the <em>arg0</em> in the
<em>:keyword-in-first-argument-map</em> mnemonic has been rewritten to <em>arg2</em>.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="p">(</span><span class="nf">clojure.core.contracts/contract</span><span class="w"> </span><span class="n">ctx-aspect2879</span><span class="w"> </span><span class="s">"\"ctx-aspect2879\""</span><span class="w"> </span><span class="p">[</span><span class="n">arg0</span><span class="w"> </span><span class="n">arg1</span><span class="w"> </span><span class="n">arg2</span><span class="p">]</span><span class="w"> </span><span class="p">[(</span><span class="nb">map?</span><span class="w"> </span><span class="n">arg0</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="nb">keyword?</span><span class="w"> </span><span class="p">(</span><span class="nb">keys</span><span class="w"> </span><span class="n">arg0</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="n">number?</span><span class="w"> </span><span class="p">(</span><span class="nb">vals</span><span class="w"> </span><span class="n">arg0</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">string?</span><span class="w"> </span><span class="n">arg1</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">keyword?</span><span class="w"> </span><span class="n">arg2</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">contains?</span><span class="w"> </span><span class="n">arg0</span><span class="w"> </span><span class="n">arg2</span><span class="p">)</span><span class="w"> </span><span class="n">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">number?</span><span class="w"> </span><span class="n">%</span><span class="p">)])</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h1 id="beware-mnemonic-gotchasa-idorgheadline44a">Beware mnemonic gotchas<a id="orgheadline44"></a></h1>

<p>The code tries to be as aggressive as possible to catch
inconsistencies and ensure your get what
you want. But there are some things to be aware of.</p>

<h4 id="beware-mnemonic-gotchas---infinite-recursiona-idorgheadline41a">Beware mnemonic gotchas - infinite recursion<a id="orgheadline41"></a></h4>

<p>Because mnemonics can use other mnemonic in their definition there is the
ability to create an infinite loop if a “downstream” mnemonic refers to
an “upstream” one.</p>

<p><em>Its possible to “remember” used mnemonics during evaluation
but not done so yet - on the list of improvments.</em></p>

<h4 id="beware-mnemonic-gotchas---incompatible-argument-assertionsa-idorgheadline42a">Beware mnemonic gotchas - incompatible argument assertions<a id="orgheadline42"></a></h4>

<p>If a custom mnemonic’s argument assertions conflict with an explicit predicate,
built-in mnemonic (e.g. :map) or another custom mnemonic, the contract
will include more than one, but potentially incompatible,
assertions for the same argument.  Which may fail miserably.</p>

<p>Note though that duplicate assertions for the same argument will be <strong>distinct</strong>-ified and cause no issue.</p>

<h4 id="beware-mnemonic-gotchas---unexpected-argumentsa-idorgheadline43a">Beware mnemonic gotchas - unexpected arguments<a id="orgheadline43"></a></h4>

<p>If a custom mnemonic with two arguments is applied to a function expecting
e.g. only one argument, an error will occur at run time.</p>

<h1 id="contracts-with-multiple-aritiesa-idorgheadline47a">Contracts with Multiple Arities<a id="orgheadline47"></a></h1>

<p><strong>CCC</strong> supports contracts for functions with multiple arities.</p>

<p><strong>CHUGAR</strong> supports multiple arities, just put them
all in a vector on the call to e.g. <em>apply-contract-aspects</em>.</p>

<p><strong>CHUGAR</strong> raises an error if it identifies  contracts with the same
arity for the same function in the same call to the macro (e.g. <em>apply-contract-aspects</em>).</p>

<h2 id="example---two-arities-map--number-and-mapkeyword--vectora-idorgheadline45a">Example - two arities (map =&gt; number) and (map,keyword =&gt; vector)<a id="orgheadline45"></a></h2>

<p>This example of a multiple arities contract defines one arity for a single argument
function that suck a map and returns a vector; and a second arity for
a two argument function that sucks a map and keyword and spits a
vector.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></td><td class="code"><pre><span class="c1">;; Example - two arities (map =&gt; number) and (map,keyword =&gt; number)
</span><span class="w">
</span><span class="c1">;; This is the target function with two arities
</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">two-arity-fn1</span><span class="w">
  </span><span class="p">([</span><span class="n">m</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="no">:a</span><span class="w"> </span><span class="n">m</span><span class="p">))</span><span class="w">
  </span><span class="p">([</span><span class="n">m</span><span class="w"> </span><span class="n">k</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">k</span><span class="w"> </span><span class="n">m</span><span class="p">)))</span><span class="w">

</span><span class="c1">;; The constrained function
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">constrained-two-arity-fn1</span><span class="w"> </span><span class="p">(</span><span class="nf">apply-contract-aspects</span><span class="w"> </span><span class="n">two-arity-fn1</span><span class="w"> </span><span class="p">[{</span><span class="no">:suck</span><span class="w"> </span><span class="no">:map</span><span class="w"> </span><span class="no">:spit</span><span class="w"> </span><span class="no">:number</span><span class="p">}</span><span class="w"> </span><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="p">[</span><span class="no">:map</span><span class="w"> </span><span class="no">:keyword</span><span class="p">]</span><span class="w"> </span><span class="no">:spit</span><span class="w"> </span><span class="no">:vector</span><span class="p">}]))</span><span class="w">

</span><span class="c1">;; First Arity Tests
</span><span class="w">
</span><span class="c1">;; This will works as value of key :a is a number
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">constrained-two-arity-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]})</span><span class="w">

</span><span class="c1">; This will fail as value of key :a is not a number
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">constrained-two-arity-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="s">"x"</span><span class="p">})</span><span class="w">

</span><span class="c1">;; Second Arity Tests
</span><span class="w">
</span><span class="c1">;; This will work as value of key :c is a vector
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">constrained-two-arity-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]}</span><span class="w"> </span><span class="no">:c</span><span class="p">)</span><span class="w">

</span><span class="c1">; This will fail as value of key :d is not a vector (its nil)
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">constrained-two-arity-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="s">"x"</span><span class="p">}</span><span class="w"> </span><span class="no">:d</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="example---multiple-arities-using-mixed-ccc-form-and-map-forma-idorgheadline46a">Example - multiple arities using mixed CCC form and map form<a id="orgheadline46"></a></h2>

<p>The definition of the contract for each arity can be either CCC form
or map form; they can be mixed as well.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></td><td class="code"><pre><span class="c1">;; Example - multiple arities using mixed CCC form and map form 
</span><span class="w">
</span><span class="c1">;; The same multiple arity example as above but using a mixed contract definition with CCC form and map form.
</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">constrained-two-arity-fn1</span><span class="w"> </span><span class="p">(</span><span class="nf">apply-contract-aspects</span><span class="w"> </span><span class="n">two-arity-fn1</span><span class="w"> </span><span class="p">[[[</span><span class="n">m</span><span class="p">]</span><span class="w"> </span><span class="p">[</span><span class="nb">map?</span><span class="w"> </span><span class="n">=&gt;</span><span class="w"> </span><span class="n">number?</span><span class="p">]]</span><span class="w">  </span><span class="p">{</span><span class="no">:suck</span><span class="w"> </span><span class="p">[</span><span class="no">:map</span><span class="w"> </span><span class="no">:keyword</span><span class="p">]</span><span class="w"> </span><span class="no">:spit</span><span class="w"> </span><span class="no">:vector</span><span class="p">}]))</span><span class="w">

</span><span class="c1">;; First Arity Tests
</span><span class="w">
</span><span class="c1">;; This will works as value of key :a is a number
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">constrained-two-arity-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]})</span><span class="w">

</span><span class="c1">; This will fail as value of key :a is not a number
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">constrained-two-arity-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="s">"x"</span><span class="p">})</span><span class="w">

</span><span class="c1">;; Second Arity Tests
</span><span class="w">
</span><span class="c1">;; This will work as value of key :c is a vector
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-work</span><span class="w"> </span><span class="n">constrained-two-arity-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">:c</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]}</span><span class="w"> </span><span class="no">:c</span><span class="p">)</span><span class="w">

</span><span class="c1">; This will fail as value of key :d is not a vector (its nil)
</span><span class="w">
</span><span class="p">(</span><span class="nf">will-fail</span><span class="w"> </span><span class="n">constrained-two-arity-fn1</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="s">"x"</span><span class="p">}</span><span class="w"> </span><span class="no">:d</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h1 id="final-wordsa-idorgheadline48a">Final Words<a id="orgheadline48"></a></h1>

<p><strong>CHUGAR’s</strong> genesis was as part of a larger project (other parts to be published soon).</p>

<p>Writing the project has taught me a lot about 
<a href="http:///clojure.org">Clojure</a> (notably macros and protocols) and its
ecosystem (testing, profiling, Clojars and suchlike)  but I still have lots to learn.</p>

<p>I’m sure more experienced Clojurians would have some head-scratching moments if they
looked at the code.  As I tweeted recently, I think the biggest challenge
to learning a new language is to design idiomatically and well in it.
All advice on that subject gratefully received and acknowledged.</p>

<p>The whole point of <strong>CHUGAR</strong> was/is to make using the rich features of
<strong>CCC</strong> as easy  as possible.  I hope it (begins to) succeed on that
criterion and believe  <em>mnemonics</em> offers an original contribution
and productivity aid for defining, re-using and composing contract aspects.</p>

<p>I already have another article  in the works (part of the same project)
on the practical and concrete use of <strong>CHUGAR</strong> to apply aspect contracts to the
values of map keys. Coming soon!</p>

<h1 id="final-final-wordsa-idorgheadline49a">Final Final Words<a id="orgheadline49"></a></h1>

<p>The overall project is the first “serious” (as opposed to dabbling)
<a href="http:///clojure.org">Clojure</a> code I’ve written.  And the first serious
code in a functional language.</p>

<blockquote>
  <p>In all my time writing software, I
can’t ever remember learning a new language that just gets out of the
way when I’m rattling along, but gets in the way when I’m stuck and
need some help overcoming an implementation or design issue, offering
a (new to me) feature to use, or an approach to apply, to elide the
obstacle.  Clojure, as many acknowledge, rocks!</p>
</blockquote>


  </article>
  <hr />
</div>


<section class="pager">
  <ul>
    
    <li class="previous"><a href="/clojure/java/jruby/ruby/red/bridge/2013/09/20/calling-jruby-from-java-and-clojure-using-red-bridge.html" title="Calling  JRuby from Java and Clojure using Red Bridge">&larr; Older</a></li>
    
    
    <li class="next"><a href="/clojure/map/aspect/contract/2014/03/19/two-sugars-with-your-contracts-for-clojure-maps.html" title="Two sugars with your Contracts for Clojure Maps">Newer &rarr;</a></li>
    
  </ul>
</section>

<script src="/js/jquery-1.9.1.min.js"></script>
<script type="text/javascript">
$(function(){
  $(document).keydown(function(e) {
    if (e.target.nodeName.toUpperCase() != 'BODY') return;
    var url = false;
        if (e.which == 37 || e.which == 74) {  // Left arrow and J
            
        url = 'http://www.rumford.name/clojure/java/jruby/ruby/red/bridge/2013/09/20/calling-jruby-from-java-and-clojure-using-red-bridge.html';
        
        }
        else if (e.which == 39 || e.which == 75) {  // Right arrow and K
            
        url = 'http://www.rumford.name/clojure/map/aspect/contract/2014/03/19/two-sugars-with-your-contracts-for-clojure-maps.html';
        
        }
        if (url) {
            window.location = url;
        }
  });
})
</script>



<div id="disqus_thread"></div>

<script type="text/javascript">

  var disqus_developer = 1;

var disqus_shortname ='';
/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>

<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



    <section class="pager">
  
  
</section>

<script src="/js/jquery-1.9.1.min.js"></script>
<script type="text/javascript">
$(function(){
  $(document).keydown(function(e) {
    if (e.target.nodeName.toUpperCase() != 'BODY') return;
    var url = false;
        if (e.which == 37 || e.which == 74) {  // Left arrow and J
        
        }
        else if (e.which == 39 || e.which == 75) {  // Right arrow and K
            
        }
        if (url) {
            window.location = url;
        }
  });
})
</script>



  </div>
  <div class="col-sm-2">
<div class="sidebar-module about">
  <h4>About Me</h4>
  <img title="Whistlejacket" src="/images/whistlejacket-circle-128px-2.png" alt="Whistlejacket"/>
  <span>Ian Rumford's whisperings</span>
  <br />

  

  You can contact me via: <br />

  
  <a href="mailto:ian@rumford.name" title="mailto: ian@rumford.name"><i class="fa fa-envelope-square fa-3x"></i></a>&nbsp;
  
  
  <a href="https://github.com/ianrumford" title="GithubID: ianrumford"><i class="fa fa-github-square fa-3x"></i></a>&nbsp;
  
  
  <a href="https://twitter.com/ianrumford" title="TwitterID: ianrumford"><i class="fa fa-twitter-square fa-3x"></i></a>
  

  

</div>

<div class="sidebar-module">
  <h4>Site Search</h4>
  <form onsubmit="search_google()" >
    <input type="text" id="google-search" placeholder="Google search" />
    <input type="submit" name="sa" value="Go" />
  </form>
</div>


<div class="sidebar-module"> <!-- sidebar-module-inset">-->
  <h4>Copyright Notice</h4>

  

  <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">
    <img src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png">
  </a>
  <br />
  <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Attribution-NonCommercial-ShareAlike</a>

  

</div>


<div class="sidebar-module">
  <h4>Recent Posts</h4>
  
  <li>
  <a href="/elixir/doctest/individual/2017/11/20/testing-individual-elixir-doctests.html" title="Testing Individual Elixir Doctests" rel="bookmark">Testing Individual Elixir Doctests</a>
  </li>
  
  <li>
  <a href="/elixir/metaprogramming/postwalk/2017/05/17/metaprogramming-without-macros.html" title="Metaprogramming Without Macros" rel="bookmark">Metaprogramming Without Macros</a>
  </li>
  
  <li>
  <a href="/elixir/siariwyd/callback/function/share/reuse/2016/11/17/siariwyd.html" title="Sharing and Reusing Elixir Callback Functions between Modules" rel="bookmark">Sharing and Reusing Elixir Callback Functions between Modules</a>
  </li>
  
  <li>
  <a href="/elixir/pattern/matching/runtime/polymorphism/2016/09/19/pattern-matching-to-polymorphism.html" title="Pattern Matching to Polymorphism - an Unexpected Journey" rel="bookmark">Pattern Matching to Polymorphism - an Unexpected Journey</a>
  </li>
  
  <li>
  <a href="/elixir/map/api/genserver/module/agent/state/2016/09/13/amlapio.html" title="Adding a Map API to a GenServer or Module with Agent-held State" rel="bookmark">Adding a Map API to a GenServer or Module with Agent-held State</a>
  </li>
  
</div>


<div class="sidebar-module">
  <h4>Tags</h4>
  
    <a href="/tags/#hello world" title="hello world" rel="1">hello world</a> &nbsp;
  
    <a href="/tags/#octopress" title="octopress" rel="1">octopress</a> &nbsp;
  
    <a href="/tags/#jekyll" title="jekyll" rel="1">jekyll</a> &nbsp;
  
    <a href="/tags/#blog" title="blog" rel="1">blog</a> &nbsp;
  
    <a href="/tags/#emacs" title="emacs" rel="2">emacs</a> &nbsp;
  
    <a href="/tags/#Ubuntu" title="Ubuntu" rel="1">Ubuntu</a> &nbsp;
  
    <a href="/tags/#precise" title="precise" rel="2">precise</a> &nbsp;
  
    <a href="/tags/#pangolin" title="pangolin" rel="1">pangolin</a> &nbsp;
  
    <a href="/tags/#12.04" title="12.04" rel="1">12.04</a> &nbsp;
  
    <a href="/tags/#clojure" title="clojure" rel="1">clojure</a> &nbsp;
  
    <a href="/tags/#leinginen" title="leinginen" rel="1">leinginen</a> &nbsp;
  
    <a href="/tags/#slime" title="slime" rel="1">slime</a> &nbsp;
  
    <a href="/tags/#swank" title="swank" rel="1">swank</a> &nbsp;
  
    <a href="/tags/#ubuntu" title="ubuntu" rel="1">ubuntu</a> &nbsp;
  
    <a href="/tags/#ruby" title="ruby" rel="1">ruby</a> &nbsp;
  
    <a href="/tags/#windows" title="windows" rel="1">windows</a> &nbsp;
  
    <a href="/tags/#ole" title="ole" rel="1">ole</a> &nbsp;
  
    <a href="/tags/#property" title="property" rel="1">property</a> &nbsp;
  
    <a href="/tags/#values" title="values" rel="1">values</a> &nbsp;
  
</div>


<div class="sidebar-module">
  <h4>Archives</h4>

  
  
  
  
  
  <li id="2017" > <a href="/archives/#2017">2017</a></li>
  
  
  
  
  
  
  
  
  
  <li id="2016" > <a href="/archives/#2016">2016</a></li>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <li id="2014" > <a href="/archives/#2014">2014</a></li>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <li id="2013" > <a href="/archives/#2013">2013</a></li>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <li id="2012" > <a href="/archives/#2012">2012</a></li>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

</div>


</div>



  

  <footer class="site-footer">

  <p>Copyright &copy; <a href="/">An Ostler in IT</a></p>
  <p>Powered by <a href="https://github.com/jekyll/jekyll">Jekyll</a> 
  on 
  
  <a href="https://github.com/">Github</a>
  
  | Theme <a href="https://github.com/yulijia/freshman21/">Freshman21</a> Design by <a href="http://yulijia.net">Lijia Yu</a>
  | Adapted by Ian Rumford  


  <div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;">
    <a title="Back To Top"><img src="/images/topbutton.png"/></a>
  </div>

  <script src="/js/jquery-1.9.1.min.js"></script>
  <script src="/js/totop.js"></script>  



</footer>


</div>

</body>

</html>
