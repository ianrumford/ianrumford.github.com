<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width initial-scale=1">

<meta property="og:title" content="Writing Apache Pig UDFs in Clojure">
<title>Writing Apache Pig UDFs in Clojure</title>
<meta property="og:description" content="A previous post explored writing Apache Pig user defined functions (UDFs) in JRuby.This post explores writing equivalent UDFs in Clojure.Prima facie, a Cloju...">
<meta property="og:url" content="http://www.rumford.name/clojure/apache/pig/udf/2012/09/21/writing-apache-pig-udfs-in-clojure.html">
<meta property="og:site_name" content="An Ostler in IT">
<meta property="og:locale" content="en_UK">
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@ianrumford">
<meta name="twitter:creator" content="@ianrumford">
<meta name="twitter:title" content="Writing Apache Pig UDFs in Clojure">
<meta name="twitter:description" content="A previous post explored writing Apache Pig user defined functions (UDFs) in JRuby.This post explores writing equivalent UDFs in Clojure.Prima facie, a Cloju...">
<meta name="twitter:url" content="http://www.rumford.name/clojure/apache/pig/udf/2012/09/21/writing-apache-pig-udfs-in-clojure.html">

<meta name="keywords" content="IT Ostler Horses Courses">

<link rel="icon" href="/images/favicon.ico">
<link rel="stylesheet" href="/css/main.css">
<link rel="canonical" href="http://www.rumford.name/clojure/apache/pig/udf/2012/09/21/writing-apache-pig-udfs-in-clojure.html">
<link rel="alternate" type="application/atom+xml" title="An Ostler in IT" href="http://www.rumford.name/feed.xml" />

<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script language="Javascript" type="text/javascript">
function search_google()
{
  var query = document.getElementById("google-search").value;
  window.open("http://google.com/search?q=" + query
      + "%20site:" + "http://www.rumford.name");
}
</script>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');

</script>


<script type='text/javascript'>
var blocklink = ['http://humanorightswatch.org','http://o-o-6-o-o.com','http://darodar.com','http://blackhatworth.com','http://hulfingtonpost.com','http://bestwebsitesawards.com','http://darodar.com','http://buttons-for-website.com','http://ilovevitaly.co','http://semalt.com','http://priceg.com','http://simple-share-buttons.com','http://googlsucks.com','http://4webmasters.org','http://aliexpress.com','http://addons.mozilla.org/en-US/firefox/addon/ilovevitaly/','http://free-share-buttons.com','http://buttons-for-your-website.com','http://theguardlan.com','http://buy-cheap-online.info','http://best-seo-offer.com','http://4webmasters.org','http://trafficmonetize.org','http://howtostopreferralspam.eu','http://ilovevitaly.com','http://sanjosestartups.com','http://free-social-buttons.com','http://best-seo-offer.com','http://guardlink.org','http://www.event-tracking.com','http://www3.free-social-buttons.com','http://www1.free-social-buttons.com','http://www2.free-social-buttons.com','http://websites-reviews.com','http://floating-share-buttons.com','http://satellite.maps.ilovevitaly.com','http://free-social-buttons.com','http://www.event-tracking.com','http://erot.co'];
for (var b = blocklink.length; b--;) {
  if (document.referrer.match(blocklink[b]))
    window.location = "http://www.google.com";
}
</script>



<link type="application/atom+xml" rel="alternate" href="http://www.rumford.name/atom.xml" title="An Ostler in IT" />
</head>


<body>

<div class="container">

  <header class="site-header">

  <div class="wrapper">

    <h1 class="site-title"><a href="/">An Ostler in IT</a></h1>
    <h3 class="site-meta">Horses for Courses</h3>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
      <div class="trigger">
        
        
        <a class="page-link" href="/">Home</a>
        
        
        
        <a class="page-link" href="/about/">About</a>
        
        
        
        <a class="page-link" href="/archives/">Archives</a>
        
        
        
        <a class="page-link" href="/categories/">Categories</a>
        
        
        
        <a class="page-link" href="/tags/">Tags</a>
        
        
        
        <a class="page-link" href="/guestbook/"></a>
        
        
        
        <a class="page-link" href="/feed.xml"></a>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      </div>
    </nav>

  </div>

</header>


    

  <div class="page-content col-sm-8">
    <div class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 itemprop="name" class="post-title">Writing Apache Pig UDFs in Clojure</h1>
    <meta itemprop="keywords" content="" />
    <p class="post-meta">
    Posted in
    
    <a href="/categories/#clojure">clojure</a>, 
    
    <a href="/categories/#apache">apache</a>, 
    
    <a href="/categories/#pig">pig</a>, 
    
    <a href="/categories/#udf">udf</a>
     
    
    <time itemprop="datePublished" datetime="2012-09-21">
    on Sep 21, 2012
    </time>
    </p>
  </header>

  <article class="post-content" itemprop="articleBody">
    <p>A previous <a href="http://ianrumford.github.com/blog/2012/09/17/writing-apache-pig-udfs-in-jruby/">post</a> explored writing 
Apache <a href="http://pig.apache.org/">Pig</a> <em>user defined functions</em> (UDFs) in <a href="http://jruby.org/">JRuby</a>.</p>

<p>This post explores writing equivalent UDFs in <a href="http://clojure.org/">Clojure</a>.</p>

<p><em>Prima facie</em>, a Clojure UDF, because it compiles directly to Java bytecode,
should integrate extremely well with Pig’s Java code.  There
shouldn’t be any <em>impedance mismatches</em> between the two languages and
performance should be essentially the same as if the UDF were to be
written in Java itself.</p>

<p>But there doesn’t seem to have been much prior experimentation with Clojure
UDFs.  Perhaps this quote from a Pig wiki
<a href="http://wiki.apache.org/pig/TuringCompletePig">page</a> when Clojure was
a candidate for <em>adding control flow and modularity constructs to Pig</em>
may help to explain the reticence:</p>

<blockquote>
  <p>“Clojure is a functional language, a paradigm which seems to engender one of love, terror, or confusion. As such, it probably is not a good choice for Pig Latin. Also, Cascalog already exists for those who like Clojure.”</p>
</blockquote>

<p>Even us junior members of the <em>Parentherati</em> would view this as
shorted sighted.</p>

<p>However I did find one old-ish but particularly useful example: Matt
Kangas’s proof-of-concept
<a href="https://github.com/kangas/mountain-pig">mountain-pig</a>.  Matt’s code
was useful to me on both the Java - Clojure interop (new territory to
me) and also how to comply with Pig’s UDF implementation requirements (API).
You will see snippets of Matt’s code in the example below.  Thanks
Matt!</p>

<p>It turns out that writing Pig UDFs in Clojure is as easy to
writing them in JRuby; the setup is a bit more involved but after that
it is plain sailing.</p>

<p>But the potential to exploit fully the Java UDF
API in Clojure
is (IMHO) more obvious than JRuby, Python or JavaScript:  I think (qualitatively) the Clojure - Java interop would make it
easier to write more closely integrated  UDFs in
Clojure.</p>

<p>The rest of this post follows broadly the same structure as the JRuby
post and it is worth reading that post  as its very much a scene setter.  In
this post I focus on
writing Clojure UDFs to return a scalars (string), maps (hashes) and
(Pig) <em>tuples</em>.  As before, the results are destined to be stored in HBase.</p>

<p>Also, as before, the log file was from a
Ubuntu audit subsystem log (<em>auditd</em>).</p>

<!-- more -->

<h1 id="preparation">Preparation</h1>

<p>The JRuby
<a href="http://ianrumford.github.com/blog/2012/09/17/writing-apache-pig-udfs-in-jruby/">post</a>
has  details on:</p>

<ul>
  <li>Installing HBase and Pig</li>
  <li>
    <p>Creating the HBase
table and column family</p>

    <p>The tables names are given in the various Pig Latin scripts, the
  column family is always <em>record</em>.</p>
  </li>
  <li>
    <p>How to execute a Pig Latin script</p>

    <p>But note the change to how to set the classpath using <em>lein</em> given below.</p>
  </li>
  <li>Some examples of <em>auditd</em> log records (stored in <em>./data/blog_audit1.log</em> in the Pig Latin scripts below).</li>
</ul>

<h1 id="installing-and-using-leiningen">Installing and Using Leiningen</h1>

<p><a href="https://github.com/technomancy/leiningen">Leiningen</a> (<em>lein</em>) is
broadly the equivalent of Java’s <a href="http://maven.apache.org/">maven</a> and
describes  its <em>raison d’etre</em>  as</p>

<blockquote>
  <p>“for automating Clojure projects without setting your hair on fire.”</p>
</blockquote>

<p>Installing <em>lein</em> is a matter of downloading the
<a href="https://raw.github.com/technomancy/leiningen/preview/bin/lein">script</a>
and saving it somewhere e.g.</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5</pre></td><td class="code"><pre><span class="nb">cd</span> /tmp
wget https://raw.github.com/technomancy/leiningen/preview/bin/lein
mv lein /usr/bin
chown root.root /usr/bin/lein
chmod 755 /usr/bin/lein<span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>To create a new Leiningen project is as simple as:</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre><span class="nb">cd</span> /home/me/where/i/keep/my/projects
lein new blog_cljudf<span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>The new folder (<em>blog_cljudf</em>) will have, amongst other things, a
<a href="https://github.com/technomancy/leiningen/blob/preview/sample.project.clj">project.clj</a>
file which specifies dependencies, source code directories, etc.  The
project.clj file is a Clojure program.</p>

<p>All of the following <em>lein</em>  commands must be run while in
the <em>blog_cljudf</em> folder.</p>

<p>Once written, all of the Clojure and Java code must  be compiled and  a
jar created that can be used / specified in a Pig Latin script:</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>lein jar<span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>The jar (e.g. <em>blog_cljudf-0.1.0-SNAPSHOT.jar</em>) will be created in the
<em>./target</em> folder.</p>

<p>The classpath for the Pig Latin scripts should be set by executing
<em>lein</em> with the <em>classpath</em> option:</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="nb">export </span><span class="nv">PIG_CLASSPATH</span><span class="o">=</span><span class="s2">"</span><span class="sb">`</span>lein classpath<span class="sb">`</span><span class="s2">"</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h1 id="configuring-the-projectclj-file">Configuring the project.clj file</h1>

<p>The project.clj is shown below:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20</pre></td><td class="code"><pre><span class="p">(</span><span class="nf">defproject</span><span class="w"> </span><span class="n">blog_cljudf</span><span class="w"> </span><span class="s">"0.1.0-SNAPSHOT"</span><span class="w">

  </span><span class="no">:description</span><span class="w"> </span><span class="s">"Pig UDFs written in Clojure"</span><span class="w">

  </span><span class="no">:url</span><span class="w"> </span><span class="s">"http://example.com/FIXME"</span><span class="w">

  </span><span class="no">:license</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Eclipse Public License"</span><span class="w">
            </span><span class="no">:url</span><span class="w"> </span><span class="s">"http://www.eclipse.org/legal/epl-v10.html"</span><span class="p">}</span><span class="w">
  
  </span><span class="no">:dependencies</span><span class="w"> </span><span class="p">[[</span><span class="n">org.clojure/clojure</span><span class="w"> </span><span class="s">"1.4.0"</span><span class="p">]</span><span class="w">
                 </span><span class="p">[</span><span class="n">org.apache.hadoop/hadoop-core</span><span class="w"> </span><span class="s">"0.20.2"</span><span class="p">]</span><span class="w">
                 </span><span class="p">[</span><span class="n">org.apache.hbase/hbase</span><span class="w"> </span><span class="s">"0.94.1"</span><span class="p">]</span><span class="w">
                 </span><span class="p">[</span><span class="n">org.apache.pig/pig</span><span class="w"> </span><span class="s">"0.10.0"</span><span class="p">]</span><span class="w">
                 </span><span class="p">]</span><span class="w">

  </span><span class="no">:aot</span><span class="w"> </span><span class="p">[</span><span class="o">#</span><span class="s">"blog_cljudf*"</span><span class="w"> </span><span class="p">]</span><span class="w">

  </span><span class="no">:java-source-paths</span><span class="w"> </span><span class="p">[</span><span class="s">"src/java"</span><span class="p">]</span><span class="w"> </span><span class="c1">; Java source is stored separately.
</span><span class="w">  
  </span><span class="no">:repositories</span><span class="w"> </span><span class="p">[[</span><span class="s">"apache"</span><span class="w"> </span><span class="s">"https://repository.apache.org/content/repositories/releases"</span><span class="p">]])</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Notes:</p>

<ul>
  <li>
    <p><em>:dependencies</em> includes version 1.4.0 of the Clojure compiler and
 runtime</p>
  </li>
  <li>
    <p>the <em>:dependencies</em> list Hadoop Core (0.20.2) HBase (0.94.1) and  Pig (0.10.0) as required</p>
  </li>
  <li>
    <p><em>:repositories</em>  adds the Apache maven repo to the search
path</p>
  </li>
  <li>
    <p><em>:aot</em>  specifies the Clojure code that must be
compiled <em>ahead of time</em></p>

    <p>aot compilation is necessary when a Java-compatible class file must be
generated by Clojure (<em>gen-class</em>). The value given above is a regular expression:  all Clojure
namespaces begining with <em>blog_cljudf</em> will be aot-ed.</p>
  </li>
  <li>
    <p><em>:java-sources-paths</em> tell Leiningen to compile the Java in these directories
<em>before</em> Clojure; these Java classes will be imported into the Clojure code.</p>
  </li>
</ul>

<p>Once the clojure.clj has been configured correctly, Leiningen can be told to
resolve (download) all the dependencies for this project:</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre>lein deps<span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h1 id="enabling-clojure-udfs-to-extend-pigs-evalfunc-abstract-class">Enabling Clojure UDFs to extend Pig’s EvalFunc abstract class</h1>

<p>Clojure can’t create a class (<em>gen-class</em>) that extends Pig’s abstract
<em>EvalFunc</em> Java class.  To get over the limitation, stub concrete classes have to be
created for the various return value types in this example i.e. string, map
and (Pig’s) tuple.</p>

<p>In the project folder, these java source files live in the
<em>:java-source-paths</em> folder (<em>src/java</em>). They are automatically
compiled by <em>lein jar</em>.</p>

<p>The map concrete class (<em>MapEvalFunc.java</em>)  looks like this:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11</pre></td><td class="code"><pre><span class="kn">package</span> <span class="n">pig_udf</span><span class="o">.</span><span class="na">stub</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.pig.EvalFunc</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.HashMap</span><span class="o">;</span>

<span class="cm">/**
 * Stub to specify a concrete type of EvalFunc.
 * Clojure's "gen-class" can't extend parameterized classes yet.
 */</span>
 
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">MapEvalFunc</span> <span class="kd">extends</span> <span class="n">EvalFunc</span> <span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&gt;</span> <span class="o">{</span>
<span class="o">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p><em>TupleEvalFunc.java</em> is</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13</pre></td><td class="code"><pre><span class="kn">package</span> <span class="n">pig_udf</span><span class="o">.</span><span class="na">stub</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.pig.EvalFunc</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.apache.pig.data.Tuple</span><span class="o">;</span>

<span class="cm">/* from Matt Kangas's mountain-pig */</span>

<span class="cm">/**
 * Stub to specify a concrete type of EvalFunc.
 * Clojure's "gen-class" can't extend parameterized classes yet.
 */</span>


<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">TupleEvalFunc</span> <span class="kd">extends</span> <span class="n">EvalFunc</span> <span class="o">&lt;</span><span class="n">Tuple</span><span class="o">&gt;</span> <span class="o">{</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h1 id="using-a-clojure-udf-returning-scalars-to-etl-audit-data">Using a Clojure UDF returning scalars to etl audit data</h1>

<h2 id="the-scalar-clojure-udf">The Scalar Clojure UDF</h2>

<p>There appears to be no way, in a Java (Clojure) <em>EvalFunc</em> UDF to call arbitrary
methods (functions) from Pig Latin:  the <em>only</em> method called is
<em>exec</em>.  Contrast this with a JRuby (and Python it seems) UDF where
additional methods can be defined and called (e.g. <em>uuid</em> in my JRuby example)</p>

<p>This makes Java/Clojure UDFs returning scalars of more limited utility
(IMHO) as one would need a separate UDF for each return value needed.</p>

<p><em>It would be possible to pass some sort of *directive</em> to the UDF to
tell it to return the <em>type</em>, <em>node</em> or whatever.  But, in this
example, its just simpler to return a map - see below.*</p>

<p>For completeness though, two UDFs are given below - one
(<em>UUIDStringUDF</em>) returning a <em>uuid</em> 
and another (<em>TypeStringUDF</em>) returning the <em>type</em> of the audit record.</p>

<p><em>UUIDStringUDF</em>:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></td><td class="code"><pre><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">blog_cljudf.clopigstringuuid</span><span class="w">

  </span><span class="p">(</span><span class="no">:import</span><span class="w">  </span><span class="p">[</span><span class="n">org.apache.pig.EvalFunc</span><span class="p">]</span><span class="w"> 
            </span><span class="p">[</span><span class="n">org.apache.pig.data</span><span class="w"> </span><span class="n">DataType</span><span class="w"> </span><span class="n">Tuple</span><span class="w"> </span><span class="n">TupleFactory</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">java.util</span><span class="w"> </span><span class="n">UUID</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">pig_udf.stub</span><span class="w"> </span><span class="n">StringEvalFunc</span><span class="p">]</span><span class="w">
            </span><span class="p">)</span><span class="w">
  
  </span><span class="p">(</span><span class="no">:gen-class</span><span class="w">
   </span><span class="no">:name</span><span class="w"> </span><span class="n">blog_cljudf.UUIDStringUDF</span><span class="w">
   </span><span class="no">:main</span><span class="w"> </span><span class="n">true</span><span class="w">
   </span><span class="no">:extends</span><span class="w"> </span><span class="n">pig_udf.stub.StringEvalFunc</span><span class="p">)</span><span class="w">

  </span><span class="p">(</span><span class="no">:require</span><span class="w"> 
   </span><span class="p">[</span><span class="n">clojure.string</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="nb">str</span><span class="p">]</span><span class="w">
   </span><span class="p">)</span><span class="w">
  </span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-uuid</span><span class="w">
  </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">uuid</span><span class="w"> </span><span class="p">(</span><span class="nf">.toString</span><span class="w"> </span><span class="p">(</span><span class="nf">UUID/randomUUID</span><span class="p">))]</span><span class="w">
    </span><span class="n">uuid</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">-exec</span><span class="w">
  </span><span class="s">"Return a uuid - no input needed"</span><span class="w">
  </span><span class="p">[</span><span class="o">&amp;</span><span class="w"> </span><span class="n">any</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">make-uuid</span><span class="p">))</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p><em>TypeStringUDF</em>:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42</pre></td><td class="code"><pre><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">blog_cljudf.clopigstringtype</span><span class="w">

  </span><span class="p">(</span><span class="no">:import</span><span class="w">  </span><span class="p">[</span><span class="n">org.apache.pig.EvalFunc</span><span class="p">]</span><span class="w"> 
            </span><span class="p">[</span><span class="n">org.apache.pig.data</span><span class="w"> </span><span class="n">DataType</span><span class="w"> </span><span class="n">Tuple</span><span class="w"> </span><span class="n">TupleFactory</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">java.util</span><span class="w"> </span><span class="n">UUID</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">pig_udf.stub</span><span class="w"> </span><span class="n">StringEvalFunc</span><span class="p">]</span><span class="w">
            </span><span class="p">)</span><span class="w">
  
  </span><span class="p">(</span><span class="no">:gen-class</span><span class="w">
   </span><span class="no">:name</span><span class="w"> </span><span class="n">blog_cljudf.TypeStringUDF</span><span class="w">
   </span><span class="no">:main</span><span class="w"> </span><span class="n">true</span><span class="w">
   </span><span class="no">:extends</span><span class="w"> </span><span class="n">pig_udf.stub.StringEvalFunc</span><span class="p">)</span><span class="w">

  </span><span class="p">(</span><span class="no">:require</span><span class="w"> 
   </span><span class="p">[</span><span class="n">clojure.string</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="nb">str</span><span class="p">]</span><span class="w">
   </span><span class="p">)</span><span class="w">
  </span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">parse_input_record</span><span class="w">
  </span><span class="s">"Parse the text of the input record into fields in a map"</span><span class="w">
  </span><span class="p">[</span><span class="n">input_record</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">prefix_string</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">(</span><span class="nf">str/split</span><span class="w"> </span><span class="n">input_record</span><span class="w"> </span><span class="o">#</span><span class="s">"\: "</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
        </span><span class="n">prefix_pairs</span><span class="w"> </span><span class="p">(</span><span class="nf">str/split</span><span class="w"> </span><span class="n">prefix_string</span><span class="w"> </span><span class="o">#</span><span class="s">" "</span><span class="p">)</span><span class="w">
        </span><span class="n">prefix_pair_vecs</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">str/split</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="o">#</span><span class="s">"="</span><span class="p">)</span><span class="w"> </span><span class="n">prefix_pairs</span><span class="w"> </span><span class="p">)</span><span class="w">
        </span><span class="n">prefix_map</span><span class="w"> </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="n">prefix_pair_vecs</span><span class="p">)</span><span class="w">
        </span><span class="p">]</span><span class="w">
    </span><span class="n">prefix_map</span><span class="w">
    </span><span class="p">)</span><span class="w">
  </span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">parse_input_tuple</span><span class="w">
  </span><span class="s">"Parses the input tuple into a map"</span><span class="w">
  </span><span class="p">[</span><span class="o">#^</span><span class="n">Tuple</span><span class="w"> </span><span class="n">input_tuple</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">parse_input_record</span><span class="w"> </span><span class="p">(</span><span class="nf">.get</span><span class="w"> </span><span class="n">input_tuple</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
  </span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">-exec</span><span class="w">
  </span><span class="s">"Return the type of the audit record"</span><span class="w">
  </span><span class="p">[</span><span class="n">this</span><span class="w"> </span><span class="o">#^</span><span class="n">Tuple</span><span class="w"> </span><span class="n">input_tuple</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="nf">parse_input_tuple</span><span class="w"> </span><span class="n">input_tuple</span><span class="w"> </span><span class="p">)</span><span class="w">
        </span><span class="p">{</span><span class="no">:strs</span><span class="w"> </span><span class="p">[</span><span class="n">type</span><span class="p">]}</span><span class="w"> </span><span class="n">m</span><span class="p">]</span><span class="w">
    </span><span class="n">type</span><span class="p">))</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h2 id="the-scalar-pig-latin-script">The Scalar Pig Latin script</h2>

<p>The Pig Latin script goes like this:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44</pre></td><td class="code"><pre><span class="cm">/* 

Pig Clojure Scalar UDF Example

Auditd Record Parsed and Loaded into Hbase

Uses a Clojure UDFa returning Strings

*/</span>

<span class="cm">/*

Register the Clojure and Java jar

*/</span>

<span class="n">register</span> <span class="o">./</span><span class="n">target</span><span class="o">/</span><span class="n">blog_cljudf</span><span class="o">-</span><span class="mf">0.1</span><span class="o">.</span><span class="mi">0</span><span class="o">-</span><span class="n">SNAPSHOT</span><span class="o">.</span><span class="na">jar</span>

<span class="cm">/*

Load the auditd data

*/</span>

<span class="n">auditd_records</span> <span class="o">=</span> <span class="n">LOAD</span> <span class="err">'</span><span class="o">./</span><span class="n">data</span><span class="o">/</span><span class="n">blog_audit1</span><span class="o">.</span><span class="na">log</span><span class="err">'</span> <span class="n">USING</span> <span class="nf">PigStorage</span><span class="o">()</span> <span class="n">AS</span> <span class="o">(</span><span class="nl">record:</span> <span class="n">chararray</span><span class="o">);</span>

<span class="cm">/*

Creates the fields using the UDFs

*/</span>

<span class="n">auditd_fields</span> <span class="o">=</span> <span class="n">foreach</span> <span class="n">auditd_records</span> <span class="nf">generate</span> <span class="o">(</span><span class="n">chararray</span><span class="o">)</span> <span class="n">blog_cljudf</span><span class="o">.</span><span class="na">UUIDStringUDF</span><span class="o">(),</span>
                                                <span class="o">(</span><span class="n">chararray</span><span class="o">)</span> <span class="n">blog_cljudf</span><span class="o">.</span><span class="na">TypeStringUDF</span><span class="o">(</span><span class="n">record</span><span class="o">);</span>

<span class="cm">/*

Store the Audit fields into HBase records

*/</span>  

<span class="n">store</span> <span class="n">auditd_fields</span> <span class="n">into</span> <span class="err">'</span><span class="nl">hbase:</span><span class="c1">//blog_cljudf_scalar' using</span>
  <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">pig</span><span class="o">.</span><span class="na">backend</span><span class="o">.</span><span class="na">hadoop</span><span class="o">.</span><span class="na">hbase</span><span class="o">.</span><span class="na">HBaseStorage</span> <span class="o">(</span>
  <span class="err">'</span><span class="nl">record:</span><span class="n">type</span> <span class="nl">record:</span><span class="n">node</span><span class="err">'</span><span class="o">,</span> <span class="err">'</span><span class="n">loadkey</span> <span class="kc">true</span><span class="err">'</span><span class="o">);</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Notes:</p>

<ul>
  <li>Each UDF is instantiated once for each record</li>
</ul>

<p>8 The string returned by each UDF must be cast</p>

<h1 id="using-a-clojure-udf-returning-a-hash--map-to-etl-audit-data">Using a Clojure UDF returning a hash / map to etl audit data</h1>

<h2 id="the-hash--map-clojure-udf">The Hash / Map Clojure UDF</h2>

<p>As with a JRuby UDF, a more natural way to return a collection of
fields and their values is  in a hash/map.</p>

<p>The example below  returns all of the prefix fields
(<em>type</em>, <em>node</em>, <em>msg</em>) from the audit record, 
as well as an <em>id</em> key with a value generated by the <em>uuid</em> method.</p>

<p>Again, as with the JRuby example, two new fields has been added (<em>unique</em> and <em>passed</em>) to
demonstrate returning integer and boolean values.</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63</pre></td><td class="code"><pre><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">blog_cljudf.clopigmap</span><span class="w">

  </span><span class="p">(</span><span class="no">:import</span><span class="w">  </span><span class="p">[</span><span class="n">org.apache.pig.EvalFunc</span><span class="p">]</span><span class="w"> 
            </span><span class="p">[</span><span class="n">org.apache.pig.data</span><span class="w"> </span><span class="n">DataType</span><span class="w"> </span><span class="n">Tuple</span><span class="w"> </span><span class="n">TupleFactory</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">org.apache.pig.impl.util</span><span class="w"> </span><span class="n">WrappedIOException</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">java.io</span><span class="w"> </span><span class="n">IOException</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">java.util</span><span class="w"> </span><span class="n">UUID</span><span class="w"> </span><span class="n">Map</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">pig_udf.stub</span><span class="w"> </span><span class="n">MapEvalFunc</span><span class="p">]</span><span class="w">
            </span><span class="p">)</span><span class="w">
  
  </span><span class="p">(</span><span class="no">:gen-class</span><span class="w">
   </span><span class="no">:name</span><span class="w"> </span><span class="n">blog_cljudf.MapUDF</span><span class="w">
   </span><span class="no">:main</span><span class="w"> </span><span class="n">true</span><span class="w">
   </span><span class="no">:extends</span><span class="w"> </span><span class="n">pig_udf.stub.MapEvalFunc</span><span class="p">)</span><span class="w">

  </span><span class="p">(</span><span class="no">:require</span><span class="w"> 
   </span><span class="p">[</span><span class="n">clojure.string</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="nb">str</span><span class="p">]</span><span class="w">
   </span><span class="p">)</span><span class="w">
  </span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-uuid</span><span class="w">
  </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">uuid</span><span class="w"> </span><span class="p">(</span><span class="nf">.toString</span><span class="w"> </span><span class="p">(</span><span class="nf">UUID/randomUUID</span><span class="p">))]</span><span class="w">
    </span><span class="n">uuid</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">parse_input_record</span><span class="w">
  </span><span class="s">"Parse the text of the input record into fields in a map"</span><span class="w">
  </span><span class="p">[</span><span class="n">input_record</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">prefix_string</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">(</span><span class="nf">str/split</span><span class="w"> </span><span class="n">input_record</span><span class="w"> </span><span class="o">#</span><span class="s">"\: "</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
        </span><span class="n">prefix_pairs</span><span class="w"> </span><span class="p">(</span><span class="nf">str/split</span><span class="w"> </span><span class="n">prefix_string</span><span class="w"> </span><span class="o">#</span><span class="s">" "</span><span class="p">)</span><span class="w">
        </span><span class="n">prefix_pair_vecs</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">str/split</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="o">#</span><span class="s">"="</span><span class="p">)</span><span class="w"> </span><span class="n">prefix_pairs</span><span class="w"> </span><span class="p">)</span><span class="w">
        </span><span class="n">prefix_map</span><span class="w"> </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="n">prefix_pair_vecs</span><span class="p">)</span><span class="w">
        </span><span class="p">]</span><span class="w">
    </span><span class="n">prefix_map</span><span class="w">
    </span><span class="p">)</span><span class="w">
  </span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">parse_input_tuple</span><span class="w">
  </span><span class="s">"Parses the input tuple into a map"</span><span class="w">
  </span><span class="p">[</span><span class="o">#^</span><span class="n">Tuple</span><span class="w"> </span><span class="n">input_tuple</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">parse_input_record</span><span class="w"> </span><span class="p">(</span><span class="nf">.get</span><span class="w"> </span><span class="n">input_tuple</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
  </span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make_output_map</span><span class="w">
  </span><span class="s">"Takes the input tuple and creates the output map"</span><span class="w">
  </span><span class="p">[</span><span class="o">#^</span><span class="n">Tuple</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">r</span><span class="w"> </span><span class="p">(</span><span class="nf">parse_input_tuple</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="p">)</span><span class="w">
        </span><span class="n">unique</span><span class="w"> </span><span class="p">(</span><span class="nb">rand-int</span><span class="w"> </span><span class="mi">1000000</span><span class="p">)</span><span class="w">
        </span><span class="n">passed</span><span class="w"> </span><span class="n">true</span><span class="w"> 
        </span><span class="n">s</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="s">"id"</span><span class="w"> </span><span class="p">(</span><span class="nf">make-uuid</span><span class="p">)</span><span class="w"> </span><span class="s">"unique"</span><span class="w"> </span><span class="n">unique</span><span class="w"> </span><span class="s">"passed"</span><span class="w"> </span><span class="n">passed</span><span class="p">)</span><span class="w">
        </span><span class="p">]</span><span class="w">
    </span><span class="n">s</span><span class="w">
    </span><span class="p">)</span><span class="w">
  </span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">-exec</span><span class="w">
  </span><span class="s">"Entry point for Pig evaluation. Invoked on every Tuple of a given dataset."</span><span class="w">
  </span><span class="p">[</span><span class="n">this</span><span class="w"> </span><span class="o">#^</span><span class="n">Tuple</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="nf">make_output_map</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">try</span><span class="w">
      </span><span class="p">(</span><span class="nb">new</span><span class="w"> </span><span class="n">java.util.HashMap</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w">
        </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">WrappedIOException/wrap</span><span class="w"> </span><span class="s">"****woot****"</span><span class="w"> </span><span class="n">e</span><span class="p">))))))</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Notes:</p>

<ul>
  <li>
    <p>the name of the UDF class is the <em>gen-class</em> name: blog_cljudf.MapUDF</p>
  </li>
  <li>
    <p>the <em>-exec</em> method is the “entry point” for the Pig API</p>
  </li>
  <li>
    <p>the class extends Pig’s <em>EvalFunc</em> via the local stub <em>MapEvalFunc</em></p>
  </li>
</ul>

<h2 id="the-hash--map-pig-latin-script">The Hash / Map Pig Latin script</h2>

<p>The Pig Latin script is more complicated as it has to accept the Clojure
Hash, extract and cast the wanted keys’ values and store all of them in
the HBase table:</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53</pre></td><td class="code"><pre><span class="cm">/* 

Pig Clojure Map UDF Example

Auditd Records Parsed and Loaded into Hbase

Uses a Clojure UDF returning a HashMap 

*/</span>

<span class="cm">/*

Register the Clojure and Java jar

*/</span>

<span class="n">register</span> <span class="o">./</span><span class="n">target</span><span class="o">/</span><span class="n">blog_cljudf</span><span class="o">-</span><span class="mf">0.1</span><span class="o">.</span><span class="mi">0</span><span class="o">-</span><span class="n">SNAPSHOT</span><span class="o">.</span><span class="na">jar</span>

<span class="cm">/*

Load the auditd data

*/</span>

<span class="n">auditd_records</span> <span class="o">=</span> <span class="n">LOAD</span> <span class="err">'</span><span class="o">./</span><span class="n">data</span><span class="o">/</span><span class="n">blog_audit1</span><span class="o">.</span><span class="na">log</span><span class="err">'</span> <span class="n">USING</span> <span class="nf">PigStorage</span><span class="o">()</span> <span class="n">AS</span> <span class="o">(</span><span class="nl">record:</span> <span class="n">chararray</span><span class="o">);</span>

<span class="cm">/*

Creates the maps using the UDF

*/</span>

<span class="n">auditd_maps</span> <span class="o">=</span> <span class="n">foreach</span> <span class="n">auditd_records</span> <span class="n">generate</span> <span class="n">blog_cljudf</span><span class="o">.</span><span class="na">MapUDF</span><span class="o">(</span><span class="n">record</span><span class="o">);</span>

<span class="cm">/*

Create the fields from the maps

(Note it appears to be impossible to combine the UDF call and keys selection into one statement)

*/</span>

<span class="n">auditd_fields</span> <span class="o">=</span> <span class="n">foreach</span> <span class="n">auditd_maps</span> <span class="nf">generate</span> <span class="o">(</span><span class="n">chararray</span><span class="o">)</span> <span class="err">$</span><span class="mi">0</span><span class="err">#'</span><span class="n">id</span><span class="err">'</span><span class="o">,</span> <span class="o">(</span><span class="n">chararray</span><span class="o">)</span> <span class="err">$</span><span class="mi">0</span><span class="err">#'</span><span class="n">type</span><span class="err">'</span><span class="o">,</span> <span class="o">(</span><span class="n">chararray</span><span class="o">)</span> <span class="err">$</span><span class="mi">0</span><span class="err">#'</span><span class="n">node</span><span class="err">'</span><span class="o">,</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="err">$</span><span class="mi">0</span><span class="err">#'</span><span class="n">unique</span><span class="err">'</span><span class="o">,</span> <span class="o">(</span><span class="kt">boolean</span><span class="o">)</span> <span class="err">$</span><span class="mi">0</span><span class="err">#'</span><span class="n">passed</span><span class="err">'</span><span class="o">;</span>

<span class="cm">/*

Store the Audit fields into HBase records

*/</span>

<span class="n">store</span> <span class="n">auditd_fields</span> <span class="n">into</span> <span class="err">'</span><span class="nl">hbase:</span><span class="c1">//blog_cljudf_map' using</span>
  <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">pig</span><span class="o">.</span><span class="na">backend</span><span class="o">.</span><span class="na">hadoop</span><span class="o">.</span><span class="na">hbase</span><span class="o">.</span><span class="na">HBaseStorage</span> <span class="o">(</span>
  <span class="err">'</span><span class="nl">record:</span><span class="n">type</span> <span class="nl">record:</span><span class="n">node</span> <span class="nl">record:</span><span class="n">unique</span> <span class="nl">record:</span><span class="n">passed</span><span class="err">'</span><span class="o">,</span> <span class="err">'</span><span class="n">loadkey</span> <span class="kc">true</span><span class="err">'</span><span class="o">);</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Notes:</p>

<ul>
  <li>
    <p>the names of the UDF is the <em>gen-class</em> name (<em>blog_cljudf.MapUDF</em>)</p>
  </li>
  <li>
    <p>the syntax for extracting the map’s values into a tuple is different to
the JRuby example; this way is preferred as it prevents repeated
instantiations of the UDF.</p>
  </li>
</ul>

<h1 id="using-a-clojure-udf-returning-a-tuple-to-etl-audit-data">Using a Clojure UDF returning a tuple to etl audit data</h1>

<h2 id="the-tuple-clojure-udf">The Tuple Clojure UDF</h2>

<p>Pig allows a UDF to define a
<a href="http://pig.apache.org/docs/r0.8.1/piglatin_ref2.html#Schemas">schema</a>:</p>

<blockquote>
  <p>“Schemas enable you to assign names to and declare types for fields.
  Schemas are optional but we encourage you to use them whenever
  possible; type declarations result in better parse-time error
  checking and more efficient code execution.”</p>
</blockquote>

<p>Adding a schema to the UDF complicates it (compared to returning a map)
but makes the Pig Latin simpler, and arguably more intuitive.</p>

<p>The code below returns the same data as the map example but as a Pig
Tuple with a schema attached.  Much of the code
is the same though, the notable exception being the addition of the
<em>outputSchema</em> function that defines the returned tuple’s schema:</p>

<figure class="highlight"><pre><code class="language-clojure" data-lang="clojure"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81</pre></td><td class="code"><pre><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">blog_cljudf.clopigtuple</span><span class="w">

  </span><span class="p">(</span><span class="no">:import</span><span class="w">  </span><span class="p">[</span><span class="n">org.apache.pig.EvalFunc</span><span class="p">]</span><span class="w"> 
            </span><span class="p">[</span><span class="n">org.apache.pig.data</span><span class="w"> </span><span class="n">DataType</span><span class="w"> </span><span class="n">Tuple</span><span class="w"> </span><span class="n">TupleFactory</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">org.apache.pig.impl.util</span><span class="w"> </span><span class="n">WrappedIOException</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">org.apache.pig.impl.logicalLayer.schema</span><span class="w"> </span><span class="n">Schema</span><span class="w"> </span><span class="n">Schema$FieldSchema</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">java.io</span><span class="w"> </span><span class="n">IOException</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">java.util</span><span class="w"> </span><span class="n">UUID</span><span class="w"> </span><span class="n">Map</span><span class="p">]</span><span class="w">
            </span><span class="p">[</span><span class="n">pig_udf.stub</span><span class="w"> </span><span class="n">TupleEvalFunc</span><span class="p">]</span><span class="w">
            </span><span class="p">)</span><span class="w">
  
  </span><span class="p">(</span><span class="no">:gen-class</span><span class="w">
   </span><span class="no">:name</span><span class="w"> </span><span class="n">blog_cljudf.TupleUDF</span><span class="w">
   </span><span class="no">:main</span><span class="w"> </span><span class="n">true</span><span class="w">
   </span><span class="no">:extends</span><span class="w"> </span><span class="n">pig_udf.stub.TupleEvalFunc</span><span class="p">)</span><span class="w">

  </span><span class="p">(</span><span class="no">:require</span><span class="w"> 
   </span><span class="p">[</span><span class="n">clojure.string</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="nb">str</span><span class="p">]</span><span class="w">
   </span><span class="p">)</span><span class="w">
  </span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make-uuid</span><span class="w">
  </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">uuid</span><span class="w"> </span><span class="p">(</span><span class="nf">.toString</span><span class="w"> </span><span class="p">(</span><span class="nf">UUID/randomUUID</span><span class="p">))]</span><span class="w">
    </span><span class="n">uuid</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">parse_input_record</span><span class="w">
  </span><span class="s">"Parse the text of the input record into fields in a map"</span><span class="w">
  </span><span class="p">[</span><span class="n">input_record</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">prefix_string</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">(</span><span class="nf">str/split</span><span class="w"> </span><span class="n">input_record</span><span class="w"> </span><span class="o">#</span><span class="s">"\: "</span><span class="p">)</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
        </span><span class="n">prefix_pairs</span><span class="w"> </span><span class="p">(</span><span class="nf">str/split</span><span class="w"> </span><span class="n">prefix_string</span><span class="w"> </span><span class="o">#</span><span class="s">" "</span><span class="p">)</span><span class="w">
        </span><span class="n">prefix_pair_vecs</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">str/split</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="o">#</span><span class="s">"="</span><span class="p">)</span><span class="w"> </span><span class="n">prefix_pairs</span><span class="w"> </span><span class="p">)</span><span class="w">
        </span><span class="n">prefix_map</span><span class="w"> </span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="n">prefix_pair_vecs</span><span class="p">)</span><span class="w">
        </span><span class="p">]</span><span class="w">
    </span><span class="n">prefix_map</span><span class="w">
    </span><span class="p">)</span><span class="w">
  </span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">parse_input_tuple</span><span class="w">
  </span><span class="s">"Parses the input tuple into a map"</span><span class="w">
  </span><span class="p">[</span><span class="o">#^</span><span class="n">Tuple</span><span class="w"> </span><span class="n">input_tuple</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">parse_input_record</span><span class="w"> </span><span class="p">(</span><span class="nf">.get</span><span class="w"> </span><span class="n">input_tuple</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
  </span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">make_output_map</span><span class="w">
  </span><span class="s">"Takes the input tuple and creates the output map"</span><span class="w">
  </span><span class="p">[</span><span class="o">#^</span><span class="n">Tuple</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">r</span><span class="w"> </span><span class="p">(</span><span class="nf">parse_input_tuple</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="p">)</span><span class="w">
        </span><span class="n">unique</span><span class="w"> </span><span class="p">(</span><span class="nb">rand-int</span><span class="w"> </span><span class="mi">1000000</span><span class="p">)</span><span class="w">
        </span><span class="n">passed</span><span class="w"> </span><span class="n">true</span><span class="w"> 
        </span><span class="n">s</span><span class="w"> </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="s">"id"</span><span class="w"> </span><span class="p">(</span><span class="nf">make-uuid</span><span class="p">)</span><span class="w"> </span><span class="s">"unique"</span><span class="w"> </span><span class="n">unique</span><span class="w"> </span><span class="s">"passed"</span><span class="w"> </span><span class="n">passed</span><span class="p">)</span><span class="w">
        </span><span class="p">]</span><span class="w">
    </span><span class="n">s</span><span class="w">
    </span><span class="p">)</span><span class="w">
  </span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">-exec</span><span class="w">
  </span><span class="s">"Entry point for Pig evaluation. Invoked on every Tuple of a given dataset."</span><span class="w">
  </span><span class="p">[</span><span class="n">this</span><span class="w"> </span><span class="o">#^</span><span class="n">Tuple</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="nf">make_output_map</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="p">)</span><span class="w">
        </span><span class="c1">;;{:strs ["id" "type" "node" "unique" "passed"]} m
</span><span class="w">        </span><span class="p">{</span><span class="no">:strs</span><span class="w"> </span><span class="p">[</span><span class="n">id</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="nb">node</span><span class="w"> </span><span class="n">unique</span><span class="w"> </span><span class="n">passed</span><span class="p">]}</span><span class="w"> </span><span class="n">m</span><span class="w"> 
        </span><span class="n">p</span><span class="w"> </span><span class="p">(</span><span class="nf">java.util.ArrayList.</span><span class="w"> </span><span class="p">[</span><span class="n">id</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="nb">node</span><span class="w"> </span><span class="n">unique</span><span class="w"> </span><span class="n">passed</span><span class="p">])]</span><span class="w">
    </span><span class="p">(</span><span class="nf">try</span><span class="w">
      </span><span class="p">(</span><span class="nf">.newTuple</span><span class="w"> </span><span class="p">(</span><span class="nf">TupleFactory/getInstance</span><span class="p">)</span><span class="w"> </span><span class="n">p</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">catch</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="w">
        </span><span class="p">(</span><span class="nf">throw</span><span class="w"> </span><span class="p">(</span><span class="nf">WrappedIOException/wrap</span><span class="w"> </span><span class="s">"****woot****"</span><span class="w"> </span><span class="n">e</span><span class="p">))))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">-outputSchema</span><span class="w">
  </span><span class="s">"Output Schema with field names"</span><span class="w">
  </span><span class="p">[</span><span class="n">this</span><span class="w"> </span><span class="o">#^</span><span class="n">Schema</span><span class="w"> </span><span class="n">input_schema</span><span class="w"> </span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">tupleSchema</span><span class="w"> </span><span class="p">(</span><span class="nf">Schema.</span><span class="p">)</span><span class="w">
        </span><span class="n">schemaClassName</span><span class="w"> </span><span class="p">(</span><span class="nb">..</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">getClass</span><span class="w"> </span><span class="n">getName</span><span class="w"> </span><span class="n">toLowerCase</span><span class="p">)</span><span class="w">
        </span><span class="n">schemaName</span><span class="w"> </span><span class="s">"tuple_schema"</span><span class="w">
        </span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nf">.add</span><span class="w"> </span><span class="n">tupleSchema</span><span class="w"> </span><span class="p">(</span><span class="nf">Schema$FieldSchema.</span><span class="w"> </span><span class="s">"id"</span><span class="w"> </span><span class="n">DataType/CHARARRAY</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">.add</span><span class="w"> </span><span class="n">tupleSchema</span><span class="w"> </span><span class="p">(</span><span class="nf">Schema$FieldSchema.</span><span class="w"> </span><span class="s">"type"</span><span class="w"> </span><span class="n">DataType/CHARARRAY</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">.add</span><span class="w"> </span><span class="n">tupleSchema</span><span class="w"> </span><span class="p">(</span><span class="nf">Schema$FieldSchema.</span><span class="w"> </span><span class="s">"node"</span><span class="w"> </span><span class="n">DataType/CHARARRAY</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">.add</span><span class="w"> </span><span class="n">tupleSchema</span><span class="w"> </span><span class="p">(</span><span class="nf">Schema$FieldSchema.</span><span class="w"> </span><span class="s">"unique"</span><span class="w"> </span><span class="n">DataType/INTEGER</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">.add</span><span class="w"> </span><span class="n">tupleSchema</span><span class="w"> </span><span class="p">(</span><span class="nf">Schema$FieldSchema.</span><span class="w"> </span><span class="s">"passed"</span><span class="w"> </span><span class="n">DataType/BOOLEAN</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">Schema.</span><span class="w"> </span><span class="p">(</span><span class="nf">Schema$FieldSchema.</span><span class="w"> </span><span class="n">schemaName</span><span class="w"> </span><span class="n">tupleSchema</span><span class="w"> </span><span class="n">DataType/TUPLE</span><span class="w"> </span><span class="p">))))</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Notes:</p>

<ul>
  <li>
    <p>the <em>outputSchema</em> method create a Pig-compliant schema</p>
  </li>
  <li>
    <p>The (arbitrary) schema name is <em>tuple_schema</em></p>
  </li>
  <li>
    <p>The <em>exec</em> method returns a Pig Tuple populate by a Java ArrayList holding the values of the
fields (keys)</p>
  </li>
  <li>
    <p>the name of the UDF class is the <em>gen-class</em> name
(<em>blog_cljudf.TupleUDF</em>)</p>
  </li>
  <li>
    <p>the class extends Pig’s <em>EvalFunc</em> via the local stub <em>TupleEvalFunc</em></p>
  </li>
</ul>

<h2 id="the-tuple-pig-latin-script">The Tuple Pig Latin script</h2>

<p>The Pig Latin script is rather different to the map script in the way
it extract the fields from the tuple returned by the UDF:.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53</pre></td><td class="code"><pre><span class="cm">/* 

Pig Clojure Tuple UDF Example

Auditd Record Parsed and Loaded into Hbase

Uses a Clojure UDF returning a Pig Tuple with Schema

*/</span>

<span class="cm">/*

Register the Clojure and Java jar

*/</span>

<span class="n">register</span> <span class="o">./</span><span class="n">target</span><span class="o">/</span><span class="n">blog_cljudf</span><span class="o">-</span><span class="mf">0.1</span><span class="o">.</span><span class="mi">0</span><span class="o">-</span><span class="n">SNAPSHOT</span><span class="o">.</span><span class="na">jar</span>

<span class="cm">/*

Load the auditd data

*/</span>

<span class="n">auditd_records</span> <span class="o">=</span> <span class="n">LOAD</span> <span class="err">'</span><span class="o">./</span><span class="n">data</span><span class="o">/</span><span class="n">blog_audit1</span><span class="o">.</span><span class="na">log</span><span class="err">'</span> <span class="n">USING</span> <span class="nf">PigStorage</span><span class="o">()</span> <span class="n">AS</span> <span class="o">(</span><span class="nl">record:</span> <span class="n">chararray</span><span class="o">);</span>

<span class="cm">/*

Creates the tuples using the UDF

*/</span>

<span class="n">auditd_tuples</span> <span class="o">=</span> <span class="n">foreach</span> <span class="n">auditd_records</span> <span class="n">generate</span> <span class="n">blog_cljudf</span><span class="o">.</span><span class="na">TupleUDF</span><span class="o">(</span><span class="n">record</span><span class="o">);</span>

<span class="cm">/*

Create the fields from the tuples

(Note it appears to be impossible to combine the UDF call and field selection into one statement)

*/</span>

<span class="n">auditd_fields</span> <span class="o">=</span> <span class="n">foreach</span> <span class="n">auditd_tuples</span> <span class="n">generate</span> <span class="n">tuple_schema</span><span class="o">.</span><span class="na">id</span><span class="o">,</span> <span class="n">tuple_schema</span><span class="o">.</span><span class="na">type</span><span class="o">,</span> <span class="n">tuple_schema</span><span class="o">.</span><span class="na">node</span><span class="o">,</span> <span class="n">tuple_schema</span><span class="o">.</span><span class="na">unique</span><span class="o">,</span> <span class="n">tuple_schema</span><span class="o">.</span><span class="na">passed</span><span class="o">;</span>

<span class="cm">/*

Store the Audit fields into HBase records

*/</span>

<span class="n">store</span> <span class="n">auditd_fields</span> <span class="n">into</span> <span class="err">'</span><span class="nl">hbase:</span><span class="c1">//blog_cljudf_tuple' using</span>
  <span class="n">org</span><span class="o">.</span><span class="na">apache</span><span class="o">.</span><span class="na">pig</span><span class="o">.</span><span class="na">backend</span><span class="o">.</span><span class="na">hadoop</span><span class="o">.</span><span class="na">hbase</span><span class="o">.</span><span class="na">HBaseStorage</span> <span class="o">(</span>
  <span class="err">'</span><span class="nl">record:</span><span class="n">type</span> <span class="nl">record:</span><span class="n">node</span> <span class="nl">record:</span><span class="n">unique</span> <span class="nl">record:</span><span class="n">passed</span><span class="err">'</span><span class="o">,</span> <span class="err">'</span><span class="n">loadkey</span> <span class="kc">true</span><span class="err">'</span><span class="o">);</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Notes:</p>

<ul>
  <li>The schema name (<em>tuple_schema</em>) is used to extract
(<a href="http://pig.apache.org/docs/r0.8.1/piglatin_ref2.html#deref">dereference</a>) the wanted
fields from the returned tuple</li>
</ul>

<h1 id="final-words">Final Words</h1>

<p>There is quite a lot in this post to digest, especially if Clojure and
its ecosystem is unfamiliar.</p>

<p>But the <em>takeaway</em> is simple:
its quite straightforward to write Pig UDFs in Clojure.  This is hardly
a surprise of course.  And if one relegates the <em>ceremony</em> of the Java Pig
API to a <em>recipe</em>, one can get the job done quite quickly.</p>

<p>Even though I came to this post thinking JRuby would remain  my language of
choice for a UDF, I’ve come away thinking Clojure gives the best
integration and flexibility working with the Pig API, and probably the
best performance.</p>

<p>And writing
Clojure, parentheses and all, doesn’t feel at all awkward or alien.</p>


  </article>
  <hr />
</div>


<section class="pager">
  <ul>
    
    <li class="previous"><a href="/apache/pig/ruby/jruby/udf/2012/09/17/writing-apache-pig-udfs-in-jruby.html" title="Writing Apache Pig UDFs in JRuby">&larr; Older</a></li>
    
    
    <li class="next"><a href="/webrick/ftp/2012/09/21/a-one-line-http-file-server-using-webrick.html" title="A one-line http file server using Webrick">Newer &rarr;</a></li>
    
  </ul>
</section>

<script src="/js/jquery-1.9.1.min.js"></script>
<script type="text/javascript">
$(function(){
  $(document).keydown(function(e) {
    if (e.target.nodeName.toUpperCase() != 'BODY') return;
    var url = false;
        if (e.which == 37 || e.which == 74) {  // Left arrow and J
            
        url = 'http://www.rumford.name/apache/pig/ruby/jruby/udf/2012/09/17/writing-apache-pig-udfs-in-jruby.html';
        
        }
        else if (e.which == 39 || e.which == 75) {  // Right arrow and K
            
        url = 'http://www.rumford.name/webrick/ftp/2012/09/21/a-one-line-http-file-server-using-webrick.html';
        
        }
        if (url) {
            window.location = url;
        }
  });
})
</script>



<div id="disqus_thread"></div>

<script type="text/javascript">

  var disqus_developer = 1;

var disqus_shortname ='';
/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>

<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



    <section class="pager">
  
  
</section>

<script src="/js/jquery-1.9.1.min.js"></script>
<script type="text/javascript">
$(function(){
  $(document).keydown(function(e) {
    if (e.target.nodeName.toUpperCase() != 'BODY') return;
    var url = false;
        if (e.which == 37 || e.which == 74) {  // Left arrow and J
        
        }
        else if (e.which == 39 || e.which == 75) {  // Right arrow and K
            
        }
        if (url) {
            window.location = url;
        }
  });
})
</script>



  </div>
  <div class="col-sm-2">
<div class="sidebar-module about">
  <h4>About Me</h4>
  <img title="Whistlejacket" src="/images/whistlejacket-circle-128px-2.png" alt="Whistlejacket"/>
  <span>Ian Rumford's whisperings</span>
  <br />

  

  You can contact me via: <br />

  
  <a href="mailto:ian@rumford.name" title="mailto: ian@rumford.name"><i class="fa fa-envelope-square fa-3x"></i></a>&nbsp;
  
  
  <a href="https://github.com/ianrumford" title="GithubID: ianrumford"><i class="fa fa-github-square fa-3x"></i></a>&nbsp;
  
  
  <a href="https://twitter.com/ianrumford" title="TwitterID: ianrumford"><i class="fa fa-twitter-square fa-3x"></i></a>
  

  

</div>

<div class="sidebar-module">
  <h4>Site Search</h4>
  <form onsubmit="search_google()" >
    <input type="text" id="google-search" placeholder="Google search" />
    <input type="submit" name="sa" value="Go" />
  </form>
</div>


<div class="sidebar-module"> <!-- sidebar-module-inset">-->
  <h4>Copyright Notice</h4>

  

  <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">
    <img src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png">
  </a>
  <br />
  <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Attribution-NonCommercial-ShareAlike</a>

  

</div>


<div class="sidebar-module">
  <h4>Recent Posts</h4>
  
  <li>
  <a href="/elixir/doctest/individual/2017/11/20/testing-individual-elixir-doctests.html" title="Testing Individual Elixir Doctests" rel="bookmark">Testing Individual Elixir Doctests</a>
  </li>
  
  <li>
  <a href="/elixir/metaprogramming/postwalk/2017/05/17/metaprogramming-without-macros.html" title="Metaprogramming Without Macros" rel="bookmark">Metaprogramming Without Macros</a>
  </li>
  
  <li>
  <a href="/elixir/siariwyd/callback/function/share/reuse/2016/11/17/siariwyd.html" title="Sharing and Reusing Elixir Callback Functions between Modules" rel="bookmark">Sharing and Reusing Elixir Callback Functions between Modules</a>
  </li>
  
  <li>
  <a href="/elixir/pattern/matching/runtime/polymorphism/2016/09/19/pattern-matching-to-polymorphism.html" title="Pattern Matching to Polymorphism - an Unexpected Journey" rel="bookmark">Pattern Matching to Polymorphism - an Unexpected Journey</a>
  </li>
  
  <li>
  <a href="/elixir/map/api/genserver/module/agent/state/2016/09/13/amlapio.html" title="Adding a Map API to a GenServer or Module with Agent-held State" rel="bookmark">Adding a Map API to a GenServer or Module with Agent-held State</a>
  </li>
  
</div>


<div class="sidebar-module">
  <h4>Tags</h4>
  
    <a href="/tags/#hello world" title="hello world" rel="1">hello world</a> &nbsp;
  
    <a href="/tags/#octopress" title="octopress" rel="1">octopress</a> &nbsp;
  
    <a href="/tags/#jekyll" title="jekyll" rel="1">jekyll</a> &nbsp;
  
    <a href="/tags/#blog" title="blog" rel="1">blog</a> &nbsp;
  
    <a href="/tags/#emacs" title="emacs" rel="2">emacs</a> &nbsp;
  
    <a href="/tags/#Ubuntu" title="Ubuntu" rel="1">Ubuntu</a> &nbsp;
  
    <a href="/tags/#precise" title="precise" rel="2">precise</a> &nbsp;
  
    <a href="/tags/#pangolin" title="pangolin" rel="1">pangolin</a> &nbsp;
  
    <a href="/tags/#12.04" title="12.04" rel="1">12.04</a> &nbsp;
  
    <a href="/tags/#clojure" title="clojure" rel="1">clojure</a> &nbsp;
  
    <a href="/tags/#leinginen" title="leinginen" rel="1">leinginen</a> &nbsp;
  
    <a href="/tags/#slime" title="slime" rel="1">slime</a> &nbsp;
  
    <a href="/tags/#swank" title="swank" rel="1">swank</a> &nbsp;
  
    <a href="/tags/#ubuntu" title="ubuntu" rel="1">ubuntu</a> &nbsp;
  
    <a href="/tags/#ruby" title="ruby" rel="1">ruby</a> &nbsp;
  
    <a href="/tags/#windows" title="windows" rel="1">windows</a> &nbsp;
  
    <a href="/tags/#ole" title="ole" rel="1">ole</a> &nbsp;
  
    <a href="/tags/#property" title="property" rel="1">property</a> &nbsp;
  
    <a href="/tags/#values" title="values" rel="1">values</a> &nbsp;
  
</div>


<div class="sidebar-module">
  <h4>Archives</h4>

  
  
  
  
  
  <li id="2017" > <a href="/archives/#2017">2017</a></li>
  
  
  
  
  
  
  
  
  
  <li id="2016" > <a href="/archives/#2016">2016</a></li>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <li id="2014" > <a href="/archives/#2014">2014</a></li>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <li id="2013" > <a href="/archives/#2013">2013</a></li>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <li id="2012" > <a href="/archives/#2012">2012</a></li>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

</div>


</div>



  

  <footer class="site-footer">

  <p>Copyright &copy; <a href="/">An Ostler in IT</a></p>
  <p>Powered by <a href="https://github.com/jekyll/jekyll">Jekyll</a> 
  on 
  
  <a href="https://github.com/">Github</a>
  
  | Theme <a href="https://github.com/yulijia/freshman21/">Freshman21</a> Design by <a href="http://yulijia.net">Lijia Yu</a>
  | Adapted by Ian Rumford  


  <div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;">
    <a title="Back To Top"><img src="/images/topbutton.png"/></a>
  </div>

  <script src="/js/jquery-1.9.1.min.js"></script>
  <script src="/js/totop.js"></script>  



</footer>


</div>

</body>

</html>
