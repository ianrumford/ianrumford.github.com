<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width initial-scale=1">

<meta property="og:title" content="Adding a Map API to a GenServer or Module with Agent-held State">
<title>Adding a Map API to a GenServer or Module with Agent-held State</title>
<meta property="og:description" content="  TL;DR: A macro to generate a Map API for a GenServer’s state or a Module with Agent-held stateThe Trouble with StateModules often need to keep state and sh...">
<meta property="og:url" content="http://www.rumford.name/elixir/map/api/genserver/module/agent/state/2016/09/13/amlapio.html">
<meta property="og:site_name" content="An Ostler in IT">
<meta property="og:locale" content="en_UK">
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@ianrumford">
<meta name="twitter:creator" content="@ianrumford">
<meta name="twitter:title" content="Adding a Map API to a GenServer or Module with Agent-held State">
<meta name="twitter:description" content="  TL;DR: A macro to generate a Map API for a GenServer’s state or a Module with Agent-held stateThe Trouble with StateModules often need to keep state and sh...">
<meta name="twitter:url" content="http://www.rumford.name/elixir/map/api/genserver/module/agent/state/2016/09/13/amlapio.html">

<meta name="keywords" content="IT Ostler Horses Courses">

<link rel="icon" href="/images/favicon.ico">
<link rel="stylesheet" href="/css/main.css">
<link rel="canonical" href="http://www.rumford.name/elixir/map/api/genserver/module/agent/state/2016/09/13/amlapio.html">
<link rel="alternate" type="application/atom+xml" title="An Ostler in IT" href="http://www.rumford.name/feed.xml" />

<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<script language="Javascript" type="text/javascript">
function search_google()
{
  var query = document.getElementById("google-search").value;
  window.open("http://google.com/search?q=" + query
      + "%20site:" + "http://www.rumford.name");
}
</script>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');

</script>


<script type='text/javascript'>
var blocklink = ['http://humanorightswatch.org','http://o-o-6-o-o.com','http://darodar.com','http://blackhatworth.com','http://hulfingtonpost.com','http://bestwebsitesawards.com','http://darodar.com','http://buttons-for-website.com','http://ilovevitaly.co','http://semalt.com','http://priceg.com','http://simple-share-buttons.com','http://googlsucks.com','http://4webmasters.org','http://aliexpress.com','http://addons.mozilla.org/en-US/firefox/addon/ilovevitaly/','http://free-share-buttons.com','http://buttons-for-your-website.com','http://theguardlan.com','http://buy-cheap-online.info','http://best-seo-offer.com','http://4webmasters.org','http://trafficmonetize.org','http://howtostopreferralspam.eu','http://ilovevitaly.com','http://sanjosestartups.com','http://free-social-buttons.com','http://best-seo-offer.com','http://guardlink.org','http://www.event-tracking.com','http://www3.free-social-buttons.com','http://www1.free-social-buttons.com','http://www2.free-social-buttons.com','http://websites-reviews.com','http://floating-share-buttons.com','http://satellite.maps.ilovevitaly.com','http://free-social-buttons.com','http://www.event-tracking.com','http://erot.co'];
for (var b = blocklink.length; b--;) {
  if (document.referrer.match(blocklink[b]))
    window.location = "http://www.google.com";
}
</script>



<link type="application/atom+xml" rel="alternate" href="http://www.rumford.name/atom.xml" title="An Ostler in IT" />
</head>


<body>

<div class="container">

  <header class="site-header">

  <div class="wrapper">

    <h1 class="site-title"><a href="/">An Ostler in IT</a></h1>
    <h3 class="site-meta">Horses for Courses</h3>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
      <div class="trigger">
        
        
        <a class="page-link" href="/">Home</a>
        
        
        
        <a class="page-link" href="/about/">About</a>
        
        
        
        <a class="page-link" href="/archives/">Archives</a>
        
        
        
        <a class="page-link" href="/categories/">Categories</a>
        
        
        
        <a class="page-link" href="/tags/">Tags</a>
        
        
        
        <a class="page-link" href="/guestbook/"></a>
        
        
        
        <a class="page-link" href="/feed.xml"></a>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
      </div>
    </nav>

  </div>

</header>


    

  <div class="page-content col-sm-8">
    <div class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 itemprop="name" class="post-title">Adding a Map API to a GenServer or Module with Agent-held State</h1>
    <meta itemprop="keywords" content="" />
    <p class="post-meta">
    Posted in
    
    <a href="/categories/#elixir">elixir</a>, 
    
    <a href="/categories/#map">map</a>, 
    
    <a href="/categories/#api">api</a>, 
    
    <a href="/categories/#genserver">genserver</a>, 
    
    <a href="/categories/#module">module</a>, 
    
    <a href="/categories/#agent">agent</a>, 
    
    <a href="/categories/#state">state</a>
     
    
    <time itemprop="datePublished" datetime="2016-09-13">
    on Sep 13, 2016
    </time>
    </p>
  </header>

  <article class="post-content" itemprop="articleBody">
    <blockquote>
  <p>TL;DR: A macro to generate a Map API for a GenServer’s state or a Module with Agent-held state</p>
</blockquote>

<h1 id="the-trouble-with-statea-idorgheadline1a">The Trouble with State<a id="orgheadline1"></a></h1>

<p>Modules often need to keep state and share it but, as <a href="http://elixir-lang.org/getting-started/mix-otp/agent.html">getting started</a> says</p>

<blockquote>
  <p>Elixir is an immutable language where nothing is shared by default.</p>
</blockquote>

<p>In Elixir there are two basic ways of sharing state: <a href="http://elixir-lang.org/getting-started/processes.html">processes</a> and <a href="http://elixir-lang.org/getting-started/mix-otp/ets.html">ETS</a> 
(which I wont consider further).</p>

<p>Arguably the most common way of implementing process-held state is
<a href="http://elixir-lang.org/getting-started/mix-otp/genserver.html">GenServer</a>. But for a module that does little
more than hold state, <a href="http://elixir-lang.org/getting-started/mix-otp/genserver.html">GenServer</a> can be overkill.
As an alternative, an <a href="http://elixir-lang.org/docs/stable/elixir/Agent.html">Agent</a> provides a simpler,
alternative way for a module to hold and manage its state.</p>

<p>But neither <a href="http://elixir-lang.org/getting-started/mix-otp/genserver.html">GenServer</a> nor <a href="http://elixir-lang.org/docs/stable/elixir/Agent.html">Agent</a> provide any built-in API calls to manage the <strong>content</strong> of the
state, not surprisingly as the state’s value can be anything.</p>

<p>More often than not though, I want the state to be a <a href="http://elixir-lang.org/docs/stable/elixir/Map.html">map</a>, and sometimes
with keys that are (sub)maps.  So I usually want to make Map-like API calls —
<em>get</em>, <em>put</em>, <em>take</em>, <em>update</em> etc — both for the state itself and
any submaps.</p>

<p>Previously, I’ve written the wrappers manually.
This is not hard  but is just a bit tedious to do given the possible
combinations of state wrappers, submap wrappers, arities, etc (lots
and lots of <em>cut’n’paste’edit</em>!).  So recently I’ve bitten the bullet
and written a first cut of a <a href="http://elixir-lang.org/getting-started/meta/macros.html">macro</a> to do the heavy lifting.</p>

<p>The interface I wanted for my applications’ modules was to simply <em>use</em>
the module (that I’ve called <strong>Amlapio</strong>) that makes the API
<strong>wrapper</strong> functions.</p>

<blockquote>
  <p>As many will already know <em>use</em> calls the <em>__using__</em> macro in the
module being used, and the code generated by <em>__using__</em> is injected
into the caller module.</p>
</blockquote>

<p>Here’s an example (from the repo’s tests) of a module using an
<a href="http://elixir-lang.org/docs/stable/elixir/Agent.html">Agent</a> to hold its state.</p>

<p>The wanted submap wrappers are defined by the <em>agent: [:buttons, :menus, :checkboxes]</em> option.</p>

<p>To generate state wrappers the submaps have been set to nil: <em>agent: nil</em></p>

<p>Generating wrappers for only a subset of Map functions can be given using the <em>funs</em>
options e.g, for the state wrappers, <em>funs: [:get, :put, :pop]</em></p>

<p>Finally, a <em>namer</em> function has been given to name the state wrappers.  It
is passed two arguments: the map name (e.g. <em>buttons</em> for a submap,
but <em>nil</em> for a state wrapper) and the Map function name (e.g. <em>pop</em>).</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19</pre></td><td class="code"><pre><span class="k">defmodule</span> <span class="no">ExampleAgent1</span> <span class="k">do</span>

  <span class="c1"># generate wrappers for three submaps</span>
  <span class="kn">use</span> <span class="no">Amlapio</span><span class="p">,</span> <span class="ss">agent:</span> <span class="p">[</span><span class="ss">:buttons</span><span class="p">,</span> <span class="ss">:menus</span><span class="p">,</span> <span class="ss">:checkboxes</span><span class="p">]</span>

  <span class="c1"># generate *only* get, put and pop wrappers for the state itself and</span>
  <span class="c1"># use a namer function to name the wrappers "agent_state_get",</span>
  <span class="c1"># "agent_state_put" and "agent_state_pop"</span>
  <span class="kn">use</span> <span class="no">Amlapio</span><span class="p">,</span> <span class="ss">agent:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">funs:</span> <span class="p">[</span><span class="ss">:get</span><span class="p">,</span> <span class="ss">:put</span><span class="p">,</span> <span class="ss">:pop</span><span class="p">],</span>
    <span class="ss">namer:</span> <span class="k">fn</span> <span class="n">_map_name</span><span class="p">,</span> <span class="n">fun_name</span> <span class="o">-&gt;</span>
    <span class="p">[</span><span class="sd">"</span><span class="s2">agent_state_"</span><span class="p">,</span> <span class="n">to_string</span><span class="p">(</span><span class="n">fun_name</span><span class="p">)]</span> <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">join</span> <span class="o">|&gt;</span> <span class="no">String</span><span class="o">.</span><span class="n">to_atom</span>
  <span class="k">end</span>

  <span class="c1"># create the agent; note the default state is an empty map</span>
  <span class="k">def</span> <span class="n">start_link</span><span class="p">(</span><span class="n">state</span> <span class="p">\\</span> <span class="p">%{})</span> <span class="k">do</span>
    <span class="no">Agent</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="k">fn</span> <span class="o">-&gt;</span> <span class="n">state</span> <span class="k">end</span><span class="p">)</span>
  <span class="k">end</span>

<span class="k">end</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>These tests from the repo show how the submap wrappers would be used,
pretty much how you’d expect.  (The repo has tests for the state wrappers as well.)</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></td><td class="code"><pre><span class="n">test</span> <span class="sd">"</span><span class="s2">agent_submap1"</span> <span class="k">do</span>

  <span class="n">buttons_state</span> <span class="o">=</span> <span class="p">%{</span><span class="m">1</span> <span class="o">=&gt;</span> <span class="ss">:button_back</span><span class="p">,</span> <span class="m">2</span> <span class="o">=&gt;</span> <span class="ss">:button_next</span><span class="p">,</span> <span class="m">3</span> <span class="o">=&gt;</span> <span class="ss">:button_exit</span><span class="p">}</span>
  <span class="n">menus_state</span> <span class="o">=</span> <span class="p">%{</span><span class="ss">menu_a:</span> <span class="m">1</span><span class="p">,</span> <span class="ss">menu_b:</span> <span class="ss">:two</span><span class="p">,</span> <span class="ss">menu_c:</span> <span class="sd">"</span><span class="s2">tre"</span><span class="p">}</span>
  <span class="n">checkboxes_state</span> <span class="o">=</span> <span class="p">%{</span><span class="ss">checkbox_yesno:</span> <span class="p">[</span><span class="ss">:yes</span><span class="p">,</span> <span class="ss">:no</span><span class="p">],</span> <span class="ss">checkbox_bool:</span> <span class="p">[</span><span class="no">true</span><span class="p">,</span> <span class="no">false</span><span class="p">]}</span>
  <span class="n">agent_state</span> <span class="o">=</span> <span class="p">%{</span><span class="ss">buttons:</span> <span class="n">buttons_state</span><span class="p">,</span> 
                  <span class="ss">menus:</span> <span class="n">menus_state</span><span class="p">,</span> <span class="ss">checkboxes:</span> <span class="n">checkboxes_state</span><span class="p">}</span>

  <span class="c1"># create the agent</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">agent</span><span class="p">}</span> <span class="o">=</span> <span class="no">ExampleAgent1</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="n">agent_state</span><span class="p">)</span>

  <span class="c1"># some usage examples</span>

  <span class="n">assert</span> <span class="ss">:button_back</span> <span class="o">==</span> <span class="n">agent</span> <span class="o">|&gt;</span> <span class="no">ExampleAgent1</span><span class="o">.</span><span class="n">buttons_get</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
  <span class="n">assert</span> <span class="ss">:button_default</span> <span class="o">==</span> 
    <span class="n">agent</span> <span class="o">|&gt;</span> <span class="no">ExampleAgent1</span><span class="o">.</span><span class="n">buttons_get</span><span class="p">(</span><span class="m">99</span><span class="p">,</span> <span class="ss">:button_default</span><span class="p">)</span>

  <span class="n">assert</span> <span class="n">agent</span> <span class="o">==</span> <span class="n">agent</span> <span class="o">|&gt;</span> <span class="no">ExampleAgent1</span><span class="o">.</span><span class="n">menus_put</span><span class="p">(</span><span class="ss">:menu_d</span><span class="p">,</span> <span class="m">42</span><span class="p">)</span>
  <span class="n">assert</span> <span class="n">menus_state</span> <span class="o">|&gt;</span> <span class="no">Map</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="ss">:menu_d</span><span class="p">,</span> <span class="m">42</span><span class="p">)</span> <span class="o">==</span> <span class="n">agent</span> <span class="o">|&gt;</span> <span class="no">ExampleAgent1</span><span class="o">.</span><span class="n">agent_state_get</span><span class="p">(</span><span class="ss">:menus</span><span class="p">)</span>

  <span class="n">assert</span> <span class="p">{[</span><span class="ss">:yes</span><span class="p">,</span> <span class="ss">:no</span><span class="p">],</span> <span class="n">agent</span><span class="p">}</span> <span class="o">==</span> 
    <span class="n">agent</span> <span class="o">|&gt;</span> <span class="no">ExampleAgent1</span><span class="o">.</span><span class="n">checkboxes_pop</span><span class="p">(</span><span class="ss">:checkbox_yesno</span><span class="p">)</span>

<span class="k">end</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Creating wrappers for a GenServer’s state is very similar. However,
each wrapper has two “parts”: an <em>api</em> function and a <em>handle_call</em> function.</p>

<p>The <em>api</em> wrapper for e.g. `buttons_get/3` looks like this:</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="c1"># api wrapper for buttons_get</span>
<span class="k">def</span> <span class="n">buttons_get</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">button_name</span><span class="p">,</span> <span class="n">button_default</span> <span class="p">\\</span> <span class="no">nil</span><span class="p">)</span> <span class="k">do</span>
 <span class="no">GenServer</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="p">{</span><span class="ss">:buttons_get</span><span class="p">,</span> <span class="n">button_name</span><span class="p">,</span> <span class="n">button_default</span><span class="p">})</span>
<span class="k">end</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>… while the matching <em>handle_call</em> looks like:</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="k">def</span> <span class="n">handle_call</span><span class="p">({</span><span class="ss">:buttons_get</span><span class="p">,</span> <span class="n">button_name</span><span class="p">,</span> <span class="n">button_default</span><span class="p">},</span> <span class="n">_fromref</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">value</span> <span class="o">=</span> <span class="n">state</span> <span class="o">|&gt;</span> <span class="no">Map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="ss">:buttons</span><span class="p">,</span> <span class="p">%{})</span> <span class="o">|&gt;</span> <span class="no">Map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">button_name</span><span class="p">,</span> <span class="n">button_default</span><span class="p">)</span>
  <span class="p">{</span><span class="ss">:reply</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">state</span><span class="p">}</span>
<span class="k">end</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Here’s example of generating wrappers for a GenServer.</p>

<blockquote>
  <p>Remember: all <em>handle_call</em> functions must be kept together in the source else the compiler will complain.</p>
</blockquote>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35</pre></td><td class="code"><pre><span class="k">defmodule</span> <span class="no">ExampleGenServer1</span> <span class="k">do</span>

  <span class="c1"># its a genserver</span>
  <span class="kn">use</span> <span class="no">GenServer</span>

  <span class="c1"># generate API wrappers for three submaps</span>
  <span class="kn">use</span> <span class="no">Amlapio</span><span class="p">,</span> <span class="ss">genserver_api:</span> <span class="p">[</span><span class="ss">:buttons</span><span class="p">,</span> <span class="ss">:menus</span><span class="p">,</span> <span class="ss">:checkboxes</span><span class="p">]</span>

  <span class="c1"># generate *only* get, put, pop and take wrappers for the state itself and</span>
  <span class="c1"># use a namer function to name the wrappers "state_get",</span>
  <span class="c1"># "state_put", "state_pop", and "state_take"</span>
  <span class="kn">use</span> <span class="no">Amlapio</span><span class="p">,</span> <span class="ss">genserver_api:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">funs:</span> <span class="p">[</span><span class="ss">:get</span><span class="p">,</span> <span class="ss">:put</span><span class="p">,</span> <span class="ss">:pop</span><span class="p">,</span> <span class="ss">:take</span><span class="p">],</span>
    <span class="ss">namer:</span> <span class="k">fn</span> <span class="n">_map_name</span><span class="p">,</span> <span class="n">fun_name</span> <span class="o">-&gt;</span>
    <span class="p">[</span><span class="sd">"</span><span class="s2">state_"</span><span class="p">,</span> <span class="n">to_string</span><span class="p">(</span><span class="n">fun_name</span><span class="p">)]</span> <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">join</span> <span class="o">|&gt;</span> <span class="no">String</span><span class="o">.</span><span class="n">to_atom</span>
  <span class="k">end</span>

  <span class="c1"># create the genserver; note the default state is an empty map</span>
  <span class="k">def</span> <span class="n">start_link</span><span class="p">(</span><span class="n">state</span> <span class="p">\\</span> <span class="p">%{})</span> <span class="k">do</span>
    <span class="no">GenServer</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="bp">__MODULE__</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="c1"># &lt;&lt; more functions&gt;&gt;</span>

  <span class="c1"># handle_calls start here</span>

  <span class="c1"># generate the handle_call functions for three submaps' wrappers</span>
  <span class="kn">use</span> <span class="no">Amlapio</span><span class="p">,</span> <span class="ss">genserver_handle_call:</span> <span class="p">[</span><span class="ss">:buttons</span><span class="p">,</span> <span class="ss">:menus</span><span class="p">,</span> <span class="ss">:checkboxes</span><span class="p">]</span>

  <span class="c1"># generate the handle_call functions for the state wrappers.</span>
  <span class="kn">use</span> <span class="no">Amlapio</span><span class="p">,</span> <span class="ss">genserver_handle_call:</span> <span class="no">nil</span><span class="p">,</span> <span class="ss">funs:</span> <span class="p">[</span><span class="ss">:get</span><span class="p">,</span> <span class="ss">:put</span><span class="p">,</span> <span class="ss">:pop</span><span class="p">,</span> <span class="ss">:take</span><span class="p">],</span>
    <span class="ss">namer:</span> <span class="k">fn</span> <span class="n">_map_name</span><span class="p">,</span> <span class="n">fun_name</span> <span class="o">-&gt;</span>
    <span class="p">[</span><span class="sd">"</span><span class="s2">state_"</span><span class="p">,</span> <span class="n">to_string</span><span class="p">(</span><span class="n">fun_name</span><span class="p">)]</span> <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">join</span> <span class="o">|&gt;</span> <span class="no">String</span><span class="o">.</span><span class="n">to_atom</span>
  <span class="k">end</span>

<span class="k">end</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>There are tests got the GenServer example in the <a href="https://github.com/ianrumford/amlapio">repo</a> but
they look almost identical to the Agent example.</p>

<p>If you just want to give it a whirl, that
pretty much it. Its available on <a href="https://hex.pm/">Hex</a> and just needs to be
added to the dependencies in <em>mix.exs</em> in the usual way.</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="p">{</span><span class="ss">:amlapio</span><span class="p">,</span> <span class="sd">"</span><span class="s2">~&gt; 0.1.0"</span><span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>But if you are interested in a high-level explanation of how I implemented <strong>Amlapio</strong>, read on.</p>

<!-- more -->

<h1 id="code-on-githuba-idorgheadline2a">Code on Github<a id="orgheadline2"></a></h1>

<p>You might want to have a look at the <a href="https://github.com/ianrumford/amlapio">code</a> if you are
following along.</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4</pre></td><td class="code"><pre><span class="nb">cd</span> /tmp
git clone git@github.com:ianrumford/amlapio.git
<span class="nb">cd </span>amlapio
mix <span class="nb">test</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h1 id="wrapper-patternsa-idorgheadline6a">Wrapper Patterns<a id="orgheadline6"></a></h1>

<p><strong>Map</strong> has  three types of functions:  <strong>accessors</strong>
(e.g. <em>get</em>), <strong>mutators</strong> (e.g. <em>put</em>), 
 and the (four)
‘combo’ functions  that are both accessors and mutators (e.g. <em>pop</em>) (called hereafter <strong>poppers</strong>).</p>

<h2 id="wrapper-pattern-for-a-mutatora-idorgheadline3a">Wrapper Pattern for a Mutator<a id="orgheadline3"></a></h2>

<p>Here’s an example of <em>put</em>  for the
<em>buttons</em> submap of an agent
showing the steps in the wrapper, illustrating that all <strong>mutators</strong> have a common
<em>pattern</em>.</p>

<blockquote>
  <p>BTW I will be using  this wrapper as my example when I show code, etc  below unless I say otherwise.</p>
</blockquote>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></td><td class="code"><pre><span class="c1"># the buttons_put submap wrapper for an agent</span>
<span class="k">def</span> <span class="n">buttons_put</span><span class="p">(</span><span class="n">agent</span><span class="p">,</span> <span class="n">button_name</span><span class="p">,</span> <span class="n">button_value</span><span class="p">)</span> <span class="k">do</span>

  <span class="c1"># start with the agent and get its state</span>
  <span class="n">state</span> <span class="o">=</span> <span class="n">agent</span> <span class="o">|&gt;</span> <span class="no">Agent</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="k">fn</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">s</span> <span class="k">end</span><span class="p">)</span>

  <span class="n">new_buttons</span> <span class="o">=</span> <span class="n">state</span> 
  <span class="c1"># get buttons from the state (default to an empty map)</span>
  <span class="o">|&gt;</span> <span class="no">Map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="ss">:buttons</span><span class="p">,</span> <span class="p">%{})</span>
  <span class="c1"># put the button_name &amp; button_value key-value pair into buttons</span>
  <span class="o">|&gt;</span> <span class="no">Map</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">button_name</span><span class="p">,</span> <span class="n">button_value</span><span class="p">)</span>

  <span class="c1"># update the state with the new buttons submap</span>
  <span class="n">new_state</span> <span class="o">=</span> <span class="n">state</span> <span class="o">|&gt;</span> <span class="no">Map</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="ss">:buttons</span><span class="p">,</span> <span class="n">new_buttons</span><span class="p">)</span>

  <span class="c1"># update the agent with the new state</span>
  <span class="ss">:ok</span> <span class="o">=</span> <span class="n">agent</span> <span class="o">|&gt;</span> <span class="no">Agent</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="k">fn</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">new_state</span> <span class="k">end</span><span class="p">)</span>

  <span class="c1"># return the agent</span>
  <span class="n">agent</span>

<span class="k">end</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>The mutator  pattern for both an agent and GenServer wrapper has a maximum of six logical steps:</p>

<ol>
  <li>
    <p>get the state (line 5)</p>
  </li>
  <li>
    <p>(optional) get the submap of the state (line 9)</p>

    <p>This step is only needed when creating wrappers for a submap.</p>
  </li>
  <li>
    <p>run the Map API call (line 11)</p>

    <p>In this case its `Map.put/3`.</p>
  </li>
  <li>
    <p>(optional) put the (new) submap into the state (line 14)</p>

    <p>Again, this step is only needed for submap wrappers.</p>
  </li>
  <li>
    <p>update the state (line 17)</p>
  </li>
  <li>
    <p>return the result (line 20)</p>
  </li>
</ol>

<h2 id="wrapper-pattern-for-an-accessora-idorgheadline4a">Wrapper Pattern for an Accessor<a id="orgheadline4"></a></h2>

<p>The steps for an accessor (e.g. <em>buttons_get</em>) are even simpler:</p>

<ol>
  <li>
    <p>get the state</p>
  </li>
  <li>
    <p>(optional) get the submap</p>
  </li>
  <li>
    <p>run the Map API call</p>
  </li>
  <li>
    <p>return the result</p>
  </li>
</ol>

<h2 id="wrapper-pattern-for-a-poppera-idorgheadline5a">Wrapper Pattern for a Popper<a id="orgheadline5"></a></h2>

<p>The pattern for a <strong>popper</strong> (e.g. <em>buttons_pop</em>) is very similar to a <strong>mutator</strong>, the main difference being the wrapper’s result is a tuple e.g.</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="p">{</span><span class="n">button_value</span><span class="p">,</span> <span class="n">agent</span><span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>where the state of the agent no longer has the <em>button_name</em> key in the <em>buttons</em> submap.</p>

<h1 id="wrapper-generationa-idorgheadline13a">Wrapper Generation<a id="orgheadline13"></a></h1>

<p>The wrapper patterns are implicitly  <em>recipes</em> for the generation of
each wrapper’s code: each step gives rise to its own <em>fragment</em> of code.</p>

<p>Sometimes the code <em>fragment</em> will be <em>nil</em> e.g state wrappers have no submaps
so steps 2 &amp; 4 (of the <strong>mutator</strong>) will be <em>nil</em>.</p>

<h2 id="wrapper-generation-spec-mapwrapa-idorgheadline7a">Wrapper Generation Spec (<em>map_wrap</em>)<a id="orgheadline7"></a></h2>

<p>Amlapio’s <em>__using__</em> macro doesn’t do all that much, it just hands off its arguments to the `Amlapio.process_opts/1` function.</p>

<p><strong>process_opts</strong> creates a list of maps (called a <em>map_wrap</em> in the code), one for <strong>every</strong> wrapper name &amp; arity combo e.g.</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3</pre></td><td class="code"><pre><span class="c1"># the map_wrap for an agent's buttons_put wrapper</span>
<span class="p">%{</span><span class="ss">fun_type:</span> <span class="ss">:mutator</span><span class="p">,</span> <span class="ss">fun_name:</span> <span class="ss">:buttons_put</span><span class="p">,</span> <span class="ss">fun_arity:</span> <span class="m">3</span><span class="p">,</span>
  <span class="ss">map_type:</span> <span class="ss">:agent</span><span class="p">,</span> <span class="ss">map_name:</span> <span class="ss">:buttons</span><span class="p">,</span> <span class="ss">map_fun:</span> <span class="ss">:put</span><span class="p">}</span> <span class="o">=</span> <span class="n">map_wrap</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<blockquote>
  <p>btw map_name is always nil for a state wrapper</p>
</blockquote>

<p><strong>The values of the <em>map_wrap’s</em> keys enable normal pattern matching to be used to determine the wrapper being generated and acts accordingly.</strong></p>

<p>(During generation, the code fragment is usually stored under the <em>:fun_ast</em> key.)</p>

<h2 id="wrapper-generation-dsla-idorgheadline12a">Wrapper Generation DSL<a id="orgheadline12"></a></h2>

<p>To define a wrapper’s <em>recipe</em> in a programmable way, I’ve invented a very
simple <a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a> (implemented by `Amlapio.DSL`).</p>

<p>The dsl essentially defines a pipeline of transforms that takes the initial <em>map_wrap</em> and incrementally builds the full code for an specific wrapper.</p>

<p>Here is an example of the “top level” <em>make_fun</em> dsl:</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="c1"># make_fun dsl for an agent's submap mutator e.g. buttons_put</span>
<span class="p">[</span><span class="ss">push:</span> <span class="p">[</span><span class="ss">make:</span> <span class="ss">:state_get</span><span class="p">,</span> <span class="ss">make:</span> <span class="ss">:assign_state</span><span class="p">],</span>
 <span class="ss">push:</span> <span class="p">[</span><span class="ss">make:</span> <span class="ss">:make_body</span><span class="p">],</span>
 <span class="ss">push:</span> <span class="p">[</span><span class="ss">make:</span> <span class="ss">:state_put</span><span class="p">],</span>
 <span class="ss">push:</span> <span class="p">[</span><span class="ss">make:</span> <span class="ss">:result_value</span><span class="p">],</span>
 <span class="ss">make:</span> <span class="p">{</span><span class="o">&amp;</span><span class="no">AMLUtils</span><span class="o">.</span><span class="n">map_wrap_push_wraps_asts_reduce_recursive</span><span class="o">/</span><span class="m">1</span><span class="p">,</span> <span class="ss">:fun_def</span><span class="p">}]</span> <span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>The <em>make_body</em> is itself another dsl:</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="c1"># make_body dsl for an agent's submap mutator e.g. buttons_put</span>
<span class="p">[</span><span class="ss">push:</span>
 <span class="p">[</span><span class="ss">pipe:</span> <span class="p">[</span><span class="ss">make:</span> <span class="ss">:state</span><span class="p">,</span>
         <span class="ss">pipe:</span> <span class="p">[</span><span class="ss">pipe:</span> <span class="p">[</span><span class="ss">make:</span> <span class="ss">:state</span><span class="p">,</span> <span class="ss">make:</span> <span class="ss">:submap_get</span><span class="p">,</span> <span class="ss">make:</span> <span class="ss">:fun_apply</span><span class="p">],</span>
                <span class="ss">make:</span> <span class="p">{</span><span class="o">&amp;</span><span class="no">AMLUtils</span><span class="o">.</span><span class="n">map_wrap_ast_index_set_1</span><span class="o">/</span><span class="m">1</span><span class="p">,</span> <span class="ss">:submap_put</span><span class="p">}]],</span>
  <span class="ss">make:</span> <span class="ss">:assign_state</span><span class="p">]]</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>Each individual  dsl is a <a href="http://elixir-lang.org/docs/stable/elixir/Keyword.html">Keyword</a> where
the values  may themselves be another dsl, an atom (called a <em>snippet</em> - see <em>make</em>) or a tuple (explained in <em>custom logic</em>).</p>

<p>The keys in the dsl are the <strong>verbs</strong> and there are three of them: <em>push</em>, <em>pipe</em> and <em>make</em>.</p>

<h3 id="wrapper-generation-dsl-verb-makea-idorgheadline8a">Wrapper Generation DSL verb: make<a id="orgheadline8"></a></h3>

<p><em>make</em>  normally creates a <a href="http://elixir-lang.org/getting-started/meta/quote-and-unquote.html">quoted</a> fragment of code.</p>

<p>The value of the <em>make</em> verb (the <em>snippet</em> e.g. <em>state_get</em>) is the 1st argument
in the call to `Amlapio.Snippets.map_wrap_make_snippet/2`. The
2nd argument is the <em>map_wrap</em>. For example:</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="k">def</span> <span class="n">map_wrap_make_snippet</span><span class="p">(</span><span class="ss">:state_get</span><span class="p">,</span> <span class="p">%{</span><span class="ss">map_type:</span> <span class="ss">:agent</span><span class="p">}</span> <span class="o">=</span> <span class="n">_map_wrap</span><span class="p">)</span> <span class="k">do</span>
  <span class="kn">quote</span> <span class="k">do</span>
    <span class="c1"># start with the agent (pid) and get its state</span>
    <span class="n">pid</span> <span class="o">|&gt;</span> <span class="no">Agent</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="k">fn</span> <span class="n">state</span> <span class="o">-&gt;</span> <span class="n">state</span> <span class="k">end</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>The <a href="http://elixir-lang.org/getting-started/meta/quote-and-unquote.html">ast</a> returned is stored under the <em>:fun_ast</em> key.</p>

<h3 id="wrapper-generation-dsl-verb-pusha-idorgheadline9a">Wrapper Generation DSL verb: push<a id="orgheadline9"></a></h3>

<p>After running the <em>push’s</em> dsl, the returned <em>map_wrap</em> is pushed onto the tail of list held under the <em>:push_wraps</em> key in the <em>map_wrap</em></p>

<p>The <em>push</em> verb provides a way of caching a list of <em>map_wraps</em>, each of which usually has one statement of the wrapper stored under its <em>:fun_ast</em> key.</p>

<h3 id="wrapper-generation-dsl-verb-pipea-idorgheadline10a">Wrapper Generation DSL verb: pipe<a id="orgheadline10"></a></h3>

<p>Similar to <em>push</em>, <em>pipe</em> runs its dsl, but then takes all
of the <em>fun_asts</em> from the <em>map_wraps</em> returned from running each step in the dsl, and
pipes them together.</p>

<p>For example, this “clause” of the dsl above:</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2</pre></td><td class="code"><pre><span class="ss">pipe:</span> <span class="p">[</span><span class="ss">pipe:</span> <span class="p">[</span><span class="ss">make:</span> <span class="ss">:state</span><span class="p">,</span> <span class="ss">make:</span> <span class="ss">:submap_get</span><span class="p">,</span> <span class="ss">make:</span> <span class="ss">:fun_apply</span><span class="p">],</span>
       <span class="ss">make:</span> <span class="p">{</span><span class="o">&amp;</span><span class="no">AMLUtils</span><span class="o">.</span><span class="n">map_wrap_ast_index_set_1</span><span class="o">/</span><span class="m">1</span><span class="p">,</span> <span class="ss">:submap_put</span><span class="p">},</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>generates this code fragment:</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="no">Map</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="ss">:buttons</span><span class="p">,</span> <span class="n">state</span> <span class="o">|&gt;</span> <span class="no">Map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="ss">:buttons</span><span class="p">,</span> <span class="p">%{})</span> <span class="o">|&gt;</span> <span class="no">Map</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">button_name</span><span class="p">,</span> <span class="n">button_value</span><span class="p">))</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h3 id="wrapper-generation-dsl-custom-logica-idorgheadline11a">Wrapper Generation DSL: custom logic<a id="orgheadline11"></a></h3>

<p>In the dsl clause above the value of the <em>make</em> was a tuple.</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="ss">make:</span> <span class="p">{</span><span class="o">&amp;</span><span class="no">AMLUtils</span><span class="o">.</span><span class="n">map_wrap_ast_index_set_1</span><span class="o">/</span><span class="m">1</span><span class="p">,</span> <span class="ss">:submap_put</span><span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>The <em>submap_put</em> is the snippet as usual.</p>

<p>But the first element is a function that’s called with the <em>map_wrap</em> <strong>before</strong> the <em>snippet</em> is <em>made</em>.</p>

<p>More generally, the <em>make</em> value can be a 3tuple:</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="p">{</span><span class="n">funs_ante</span><span class="p">,</span> <span class="n">snippet</span><span class="p">,</span> <span class="n">funs_post</span><span class="p">}</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>where <em>funs_ante</em> and <em>funs_post</em> can be either <em>nil</em>, a function or list of functions.</p>

<p>The tuple elements are used to create a list of functions that take one argument – <em>map_wrap</em> – which are then used with `Enum.reduce/3`:</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1
2
3
4
5
6</pre></td><td class="code"><pre><span class="p">[</span><span class="n">funs_ante</span><span class="p">,</span>
 <span class="k">fn</span> <span class="n">map_wrap</span> <span class="o">-&gt;</span> <span class="n">map_wrap_dsl_verb</span><span class="p">(</span><span class="n">verb</span><span class="p">,</span> <span class="n">snippet</span><span class="p">,</span> <span class="n">map_wrap</span><span class="p">)</span> <span class="k">end</span><span class="p">,</span>
 <span class="n">funs_post</span><span class="p">]</span>
<span class="o">|&gt;</span> <span class="no">List</span><span class="o">.</span><span class="n">flatten</span>
<span class="o">|&gt;</span> <span class="no">Stream</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="o">&amp;</span><span class="n">is_nil</span><span class="o">/</span><span class="m">1</span><span class="p">)</span>
<span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">map_wrap</span><span class="p">,</span> <span class="k">fn</span> <span class="n">fun</span><span class="p">,</span> <span class="n">map_wrap</span> <span class="o">-&gt;</span> <span class="n">fun</span><span class="o">.</span><span class="p">(</span><span class="n">map_wrap</span><span class="p">)</span> <span class="k">end</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>(btw I currently use only the 2tuple form)</p>

<p>Just to complete the explanation of this example, `AmlUtils.map_wrap_ast_index_set_1/1` sets the <strong>index</strong>
value to be used in the call to
<a href="http://elixir-lang.org/docs/v1.0/elixir/Macro.html#pipe/3">`Macro.pipe/3`</a> to 1. This makes the code fragment produced by the prior <em>pipe</em></p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="n">state</span> <span class="o">|&gt;</span> <span class="no">Map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="ss">:buttons</span><span class="p">,</span> <span class="p">%{})</span> <span class="o">|&gt;</span> <span class="no">Map</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">button_name</span><span class="p">,</span> <span class="n">button_value</span><span class="p">)</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<p>… the 2nd argument of the <em>submap_put</em></p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><table style="border-spacing: 0"><tbody><tr><td class="gutter gl" style="text-align: right"><pre class="lineno">1</pre></td><td class="code"><pre><span class="no">Map</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="ss">:buttons</span><span class="p">,</span> <span class="n">state</span> <span class="o">|&gt;</span> <span class="no">Map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="ss">:buttons</span><span class="p">,</span> <span class="p">%{})</span> <span class="o">|&gt;</span> <span class="no">Map</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">button_name</span><span class="p">,</span> <span class="n">button_value</span><span class="p">))</span><span class="w">
</span></pre></td></tr></tbody></table></code></pre></figure>

<h1 id="final-wordsa-idorgheadline14a">Final Words<a id="orgheadline14"></a></h1>

<p>The use of regular pattern matching together with a very simple
<a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a> made it quite straightforward to generate the code
for the various wrapper patterns.</p>

<p>The technique is also quite extensible: by adding e.g. more calls to `Amlapio.Snippets.map_wrap_make_snippet/2`,
or maybe even new dsl verbs, one could address other code building needs.</p>

<p>Again though, it highlights that manipulating <a href="http://elixir-lang.org/getting-started/meta/quote-and-unquote.html">asts</a>, mostly using the
functions you use day in and day out, is really no more difficult than any other challenge in Elixir.</p>

<p>+1 <a href="http://elixir-lang.org/getting-started/meta/macros.html">macros</a></p>


  </article>
  <hr />
</div>


<section class="pager">
  <ul>
    
    <li class="previous"><a href="/elixir/pipe/clojure/thread-first/macro/2016/07/24/writing-your-own-elixir-pipe-operator.html" title="Writing your own Elixir pipe operator">&larr; Older</a></li>
    
    
    <li class="next"><a href="/elixir/pattern/matching/runtime/polymorphism/2016/09/19/pattern-matching-to-polymorphism.html" title="Pattern Matching to Polymorphism - an Unexpected Journey">Newer &rarr;</a></li>
    
  </ul>
</section>

<script src="/js/jquery-1.9.1.min.js"></script>
<script type="text/javascript">
$(function(){
  $(document).keydown(function(e) {
    if (e.target.nodeName.toUpperCase() != 'BODY') return;
    var url = false;
        if (e.which == 37 || e.which == 74) {  // Left arrow and J
            
        url = 'http://www.rumford.name/elixir/pipe/clojure/thread-first/macro/2016/07/24/writing-your-own-elixir-pipe-operator.html';
        
        }
        else if (e.which == 39 || e.which == 75) {  // Right arrow and K
            
        url = 'http://www.rumford.name/elixir/pattern/matching/runtime/polymorphism/2016/09/19/pattern-matching-to-polymorphism.html';
        
        }
        if (url) {
            window.location = url;
        }
  });
})
</script>



<div id="disqus_thread"></div>

<script type="text/javascript">

  var disqus_developer = 1;

var disqus_shortname ='';
/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>

<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



    <section class="pager">
  
  
</section>

<script src="/js/jquery-1.9.1.min.js"></script>
<script type="text/javascript">
$(function(){
  $(document).keydown(function(e) {
    if (e.target.nodeName.toUpperCase() != 'BODY') return;
    var url = false;
        if (e.which == 37 || e.which == 74) {  // Left arrow and J
        
        }
        else if (e.which == 39 || e.which == 75) {  // Right arrow and K
            
        }
        if (url) {
            window.location = url;
        }
  });
})
</script>



  </div>
  <div class="col-sm-2">
<div class="sidebar-module about">
  <h4>About Me</h4>
  <img title="Whistlejacket" src="/images/whistlejacket-circle-128px-2.png" alt="Whistlejacket"/>
  <span>Ian Rumford's whisperings</span>
  <br />

  

  You can contact me via: <br />

  
  <a href="mailto:ian@rumford.name" title="mailto: ian@rumford.name"><i class="fa fa-envelope-square fa-3x"></i></a>&nbsp;
  
  
  <a href="https://github.com/ianrumford" title="GithubID: ianrumford"><i class="fa fa-github-square fa-3x"></i></a>&nbsp;
  
  
  <a href="https://twitter.com/ianrumford" title="TwitterID: ianrumford"><i class="fa fa-twitter-square fa-3x"></i></a>
  

  

</div>

<div class="sidebar-module">
  <h4>Site Search</h4>
  <form onsubmit="search_google()" >
    <input type="text" id="google-search" placeholder="Google search" />
    <input type="submit" name="sa" value="Go" />
  </form>
</div>


<div class="sidebar-module"> <!-- sidebar-module-inset">-->
  <h4>Copyright Notice</h4>

  

  <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">
    <img src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png">
  </a>
  <br />
  <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Attribution-NonCommercial-ShareAlike</a>

  

</div>


<div class="sidebar-module">
  <h4>Recent Posts</h4>
  
  <li>
  <a href="/elixir/doctest/individual/2017/11/20/testing-individual-elixir-doctests.html" title="Testing Individual Elixir Doctests" rel="bookmark">Testing Individual Elixir Doctests</a>
  </li>
  
  <li>
  <a href="/elixir/metaprogramming/postwalk/2017/05/17/metaprogramming-without-macros.html" title="Metaprogramming Without Macros" rel="bookmark">Metaprogramming Without Macros</a>
  </li>
  
  <li>
  <a href="/elixir/siariwyd/callback/function/share/reuse/2016/11/17/siariwyd.html" title="Sharing and Reusing Elixir Callback Functions between Modules" rel="bookmark">Sharing and Reusing Elixir Callback Functions between Modules</a>
  </li>
  
  <li>
  <a href="/elixir/pattern/matching/runtime/polymorphism/2016/09/19/pattern-matching-to-polymorphism.html" title="Pattern Matching to Polymorphism - an Unexpected Journey" rel="bookmark">Pattern Matching to Polymorphism - an Unexpected Journey</a>
  </li>
  
  <li>
  <a href="/elixir/map/api/genserver/module/agent/state/2016/09/13/amlapio.html" title="Adding a Map API to a GenServer or Module with Agent-held State" rel="bookmark">Adding a Map API to a GenServer or Module with Agent-held State</a>
  </li>
  
</div>


<div class="sidebar-module">
  <h4>Tags</h4>
  
    <a href="/tags/#hello world" title="hello world" rel="1">hello world</a> &nbsp;
  
    <a href="/tags/#octopress" title="octopress" rel="1">octopress</a> &nbsp;
  
    <a href="/tags/#jekyll" title="jekyll" rel="1">jekyll</a> &nbsp;
  
    <a href="/tags/#blog" title="blog" rel="1">blog</a> &nbsp;
  
    <a href="/tags/#emacs" title="emacs" rel="2">emacs</a> &nbsp;
  
    <a href="/tags/#Ubuntu" title="Ubuntu" rel="1">Ubuntu</a> &nbsp;
  
    <a href="/tags/#precise" title="precise" rel="2">precise</a> &nbsp;
  
    <a href="/tags/#pangolin" title="pangolin" rel="1">pangolin</a> &nbsp;
  
    <a href="/tags/#12.04" title="12.04" rel="1">12.04</a> &nbsp;
  
    <a href="/tags/#clojure" title="clojure" rel="1">clojure</a> &nbsp;
  
    <a href="/tags/#leinginen" title="leinginen" rel="1">leinginen</a> &nbsp;
  
    <a href="/tags/#slime" title="slime" rel="1">slime</a> &nbsp;
  
    <a href="/tags/#swank" title="swank" rel="1">swank</a> &nbsp;
  
    <a href="/tags/#ubuntu" title="ubuntu" rel="1">ubuntu</a> &nbsp;
  
    <a href="/tags/#ruby" title="ruby" rel="1">ruby</a> &nbsp;
  
    <a href="/tags/#windows" title="windows" rel="1">windows</a> &nbsp;
  
    <a href="/tags/#ole" title="ole" rel="1">ole</a> &nbsp;
  
    <a href="/tags/#property" title="property" rel="1">property</a> &nbsp;
  
    <a href="/tags/#values" title="values" rel="1">values</a> &nbsp;
  
</div>


<div class="sidebar-module">
  <h4>Archives</h4>

  
  
  
  
  
  <li id="2017" > <a href="/archives/#2017">2017</a></li>
  
  
  
  
  
  
  
  
  
  <li id="2016" > <a href="/archives/#2016">2016</a></li>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <li id="2014" > <a href="/archives/#2014">2014</a></li>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <li id="2013" > <a href="/archives/#2013">2013</a></li>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  <li id="2012" > <a href="/archives/#2012">2012</a></li>
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

</div>


</div>



  

  <footer class="site-footer">

  <p>Copyright &copy; <a href="/">An Ostler in IT</a></p>
  <p>Powered by <a href="https://github.com/jekyll/jekyll">Jekyll</a> 
  on 
  
  <a href="https://github.com/">Github</a>
  
  | Theme <a href="https://github.com/yulijia/freshman21/">Freshman21</a> Design by <a href="http://yulijia.net">Lijia Yu</a>
  | Adapted by Ian Rumford  


  <div id="totop" style="position:fixed;bottom:150px;right:50px;cursor: pointer;">
    <a title="Back To Top"><img src="/images/topbutton.png"/></a>
  </div>

  <script src="/js/jquery-1.9.1.min.js"></script>
  <script src="/js/totop.js"></script>  



</footer>


</div>

</body>

</html>
